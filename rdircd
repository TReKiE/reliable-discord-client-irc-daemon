#!/usr/bin/env python3

import os, sys, io, stat, logging, re
import contextlib, asyncio, socket, signal, inspect, unicodedata, urllib.parse
import configparser, tempfile, datetime as dt, collections as cs, pathlib as pl


err_fmt = lambda err: '[{}] {}'.format(err.__class__.__name__, err)

class LogMessage:
	def __init__(self, fmt, a, k): self.fmt, self.a, self.k = fmt, a, k
	def __str__(self): return self.fmt.format(*self.a, **self.k) if self.a or self.k else self.fmt

class LogStyleAdapter(logging.LoggerAdapter):
	def __init__(self, logger, extra=None):
		super(LogStyleAdapter, self).__init__(logger, extra or {})
	def log(self, level, msg, *args, **kws):
		if not self.isEnabledFor(level): return
		log_kws = {} if 'exc_info' not in kws else dict(exc_info=kws.pop('exc_info'))
		msg, kws = self.process(msg, kws)
		self.logger._log(level, LogMessage(msg, args, kws), (), **log_kws)

get_logger = lambda name: LogStyleAdapter(logging.getLogger(name))

def str_part(s, sep, default=None):
	'Examples: str_part("user@host", "<@", "root"), str_part("host:port", ":>")'
	c = sep.strip('<>')
	if sep.strip(c) == '<': return (default, s) if c not in s else s.split(c, 1)
	else: return (s, default) if c not in s else s.rsplit(c, 1)

def sockopt_resolve(prefix, v):
	prefix = prefix.upper()
	for k in dir(socket):
		if not k.startswith(prefix): continue
		if getattr(socket, k) == v: return k[len(prefix):]
	return v

class adict(dict):
	def __init__(self, *args, **kws):
		super().__init__(*args, **kws)
		self.__dict__ = self

str_norm = lambda v: unicodedata.normalize('NFKC', v.strip()).casefold()

@contextlib.contextmanager
def safe_replacement(path, *open_args, mode=None, **open_kws):
	path = str(path)
	if mode is None:
		try: mode = stat.S_IMODE(os.lstat(path).st_mode)
		except OSError: pass
	open_kws.update( delete=False,
		dir=os.path.dirname(path), prefix=os.path.basename(path)+'.' )
	if not open_args: open_kws['mode'] = 'w'
	with tempfile.NamedTemporaryFile(*open_args, **open_kws) as tmp:
		try:
			if mode is not None: os.fchmod(tmp.fileno(), mode)
			yield tmp
			if not tmp.closed: tmp.flush()
			os.rename(tmp.name, path)
		finally:
			try: os.unlink(tmp.name)
			except OSError: pass



class IRCProtocolError(Exception): pass
class IRCProtocolArgsError(IRCProtocolError): pass

class IRCProtocol:

	# Extensive lists of modes are copied from freenode to make clients happy
	feats_modes = 'DOQRSZaghilopswz CFILMPQSbcefgijklmnopqrstvz'
	feats_support = ( 'AWAYLEN=200 CASEMAPPING=ascii'
		' CHANLIMIT=#:512 CHANTYPES=# CHANMODES=eIbq,k,flj,CFLMPQScgimnprstz'
		' CHANNELLEN=80 ELIST=C NETWORK=rdircd NICKLEN=64'
		' PREFIX=(ov)@+ SAFELIST STATUSMSG=@+ TOPICLEN=390 USERLEN=32' ).split()

	@classmethod
	def factory_for_bridge(cls, rdircd):
		def _wrapper():
			try: return cls(rdircd)
			except Exception as err:
				log = get_logger('rdircd.irc')
				log.exception('Failed to initialize ircd protocol: {}', err_fmt(err))
				log.critical('Stopping daemon due to unhandled protocol error')
				loop.stop()
		return _wrapper

	def __init__(self, rdircd):
		self.transport, self.buff = None, b''
		self.bridge, self.loop = rdircd, rdircd.loop
		self.log = get_logger('rdircd.irc')
		self.st = adict(
			nick=None, user=None, host=None, auth=False,
			cap_neg=False, chan_set=list() )

	def connection_made(self, tr):
		host, port = tr.get_extra_info('peername')[:2]
		self.log.debug('Connection from {}', host)
		self.transport, self.st.host = tr, host
		self.send('NOTICE * :*** rdircd ready')
		self.bridge.irc_conn_new(self)

	def data_received(self, data):
		data_len, data_repr = self._repr(data, True)
		self.log.debug('<<< [{}] {}', data_len, data_repr)
		self.buff += data
		while b'\n' in self.buff:
			line, self.buff = self.buff.split(b'\n', 1)
			if not line.strip(): continue
			self.recv(line)

	def eof_received(self): pass
	def connection_lost(self, err):
		self.log.debug('Connection lost: {}', err or 'closed cleanly')
		self.bridge.irc_conn_lost(self)

	def data_send(self, data):
		data_len, data_repr = self._repr(data, True)
		self.log.debug(' >> [{}] {}', data_len, data_repr)
		self.transport.write(data)


	def _repr(self, data, prefix=False, max_len=99, ext=' [{data_len}]'):
		if isinstance(data, str): data = data.encode()
		data_len, data_repr, ext_len = f'{len(data):03,d}', repr(data)[2:-1], len(ext)
		if len(data_repr) > max_len:
			data_len = f'{max_len}/{data_len}'
			data_repr = data_repr[:max_len - ext_len] + ext.format(data_len=data_len)
		return (data_len, data_repr) if prefix else data_repr

	def _parse(self, line):
		m = adict(line=line, params=list())
		for k in '@tags', ':src':
			pre, k = k[0], k[1:]
			if line.startswith(pre):
				try: m[k], line = line.split(' ', 1)
				except ValueError:
					raise IRCProtocolLineError(line) from None
				line = line.lstrip(' ')
			else: m[k] = None
		while True:
			if line.startswith(':'):
				m.params.append(line[1:])
				break
			if ' ' in line:
				param, line = line.split(' ', 1)
				line = line.lstrip(' ')
			else: param, line = line, ''
			m.params.append(param)
			if not line: break
		if m.params: m.cmd, m.params = m.params[0].lower(), m.params[1:]
		else: raise IRCProtocolLineError(line)
		return m

	def send(self, line_or_code, *args):
		line = line_or_code
		if isinstance(line, int): line = f'{line:03d} {self.st.nick or "*"}'
		if args: line += ' ' + ' '.join(args)
		if isinstance(line, str): line = line.encode()
		if not line.endswith(b'\n'): line += b'\r\n'
		if len(line) >= 500:
			self.log.warning('Sending line with >500B: {!r}', self._repr(line))
		self.data_send(line)

	def recv(self, line_raw, _cmd_cache=dict()):
		if isinstance(line_raw, str): line = line_raw
		else:
			try: line = line_raw.decode().strip()
			except UnicodeDecodeError:
				return self.log.error('Failed to decode line as utf-8: {!r}', self._repr(line_raw))
		try: m = self._parse(line)
		except IRCProtocolLineError:
			return self.log.error('Line protocol error: {!r}', self._repr(line_raw))
		cmd_cache = _cmd_cache.get(m.cmd)
		if cmd_cache: cmd_func, cmd_ps_n = cmd_cache
		else:
			cmd_func, cmd_ps_n = getattr(self, f'recv_cmd_{m.cmd}', None), 0
			if cmd_func:
				args = list(inspect.signature(cmd_func).parameters.values())
				cmd_ps_n = len(args)
				if cmd_ps_n == 1 and args[0].annotation == 'msg': cmd_ps_n = None
				else: cmd_ps_n = cmd_ps_n - sum(1 for p in args if p.default is not p.empty), cmd_ps_n
			_cmd_cache[m.cmd] = cmd_func, cmd_ps_n
		if not cmd_func:
			self.log.error('Unhandled cmd: {!r}', self._repr(line_raw))
			return self.send(421, ':Unknown command')
		if not self.check_access(m.cmd):
			return self.log.error('Out-of-order cmd: {!r}', self._repr(line_raw))
		if cmd_ps_n is None: cmd_func(m)
		else:
			(a, b), n = cmd_ps_n, len(m.params)
			if not a <= n <= b:
				self.log.error( 'Command/args'
					' mismatch [{} vs {}-{}]: {!r}', n, a, b, self._repr(line) )
				return self.send(461, ':Incorrect command parameters')
			cmd_func(*m.params)

	def check_access(self, cmd):
		if self.st.cap_neg: return cmd in ['cap', 'quit']
		if not (self.st.nick and self.st.user):
			res = cmd in ['cap', 'user', 'nick', 'pass', 'quit', 'ping']
			if not res: self.send(451, ':You have not registered')
			return res
		res = cmd not in ['user', 'pass']
		if not res: self.send(462, ':You may not reregister')
		return res

	def recv_cmd_ping(self, server, server_dst=None):
		self.send(f'PONG {self.bridge.server_host}')

	def recv_cmd_cap(self, sub, caps=''):
		sub = sub.lower()
		if sub == 'ls':
			self.send('CAP * LS :')
			if caps == '302': self.st.cap_neg = True
		elif sub == 'list': self.send('CAP * LIST :')
		elif sub == 'req':
			self.st.cap_neg = True
			reject = set(c for c in caps.split() if not c.startswith('-'))
			if reject: self.send(f'CAP * NAK :{caps}')
			else: self.send(f'CAP * ACK :{caps}')
		elif sub == 'end': self.st.cap_neg = False

	def recv_cmd_pass(self, pw):
		self.st.pw = pw # XXX: check vs config
		self.check_auth_done()
	def recv_cmd_user(self, name, a, b, real_name):
		self.st.update(user=name, real_name=real_name)
		self.check_auth_done()
	def recv_cmd_nick(self, nick):
		if not re.search(r'^[a-zA-Z-._]+$', nick):
			return self.send(432, nick, ':Erroneus nickname')
		if self.st.nick: self.send(':{self.st.nick} NICK {nick}')
		self.st.nick = nick
		self.check_auth_done()

	def check_auth_done(self):
		if self.st.auth: return
		if not (self.st.nick and self.st.user): return
		self.st.auth = True
		self.send(1, f':Welcome to the rdircd discord-irc bridge, {self.st.nick}')
		self.send(2,
			f':Your host is {self.bridge.server_host},'
			f' running rdircd {self.bridge.server_ver}' )
		self.send(3, ':This server was created at {}'.format(
			self.bridge.server_ts.strftime('%Y-%m-%d %H:%M:%S UTC') ))
		self.send(4, f'{self.bridge.server_host} rdircd-{self.bridge.server_ver} {self.feats_modes}')
		self.send_feats()
		self.send_stats()
		self.send_motd()

	def send_feats(self):
		feat_line, ext = list(), ':are supported by this server'
		for feat in self.feats_support:
			n, msg_len = len(feat_line), sum((len(f)+2) for f in feat_line)
			if n >= 10 or msg_len >= 200:
				self.send(5, ' '.join(feat_line), ext)
				feat_line.clear()
			feat_line.append(feat)
		self.send(5, ' '.join(feat_line), ext)

	def send_stats(self):
		s = self.bridge.irc_conn_stats()
		self.send(251, f':There are {s.auth} users and 0 invisible on {s.servers} server(s)')
		self.send(252, f'{s.op} :IRC Operators online')
		self.send(253, f'{s.unknown} :unknown connection(s)')
		self.send(254, f'{s.chans} :channels formed')
		self.send(255, f':I have {s.total} client(s) and {s.servers} server(s)')
		self.send( 265, f'{s.total} {s.total_max}',
			f':Current local users {s.total}, max {s.total_max}' )
		self.send( 266, f'{s.total} {s.total_max}',
			f':Current global users {s.total}, max {s.total_max}' )

	def send_motd(self): self.send(422, ':MOTD File is missing')

	def recv_cmd_quit(self, reason=None):
		self.send('ERROR :Connection closed')
		self.transport.close()

	def recv_cmd_join(self, chan, key=None):
		chan_list = chan.split(',')
		self.log.warning('XXX: join {}', chan_list)
		for chan in chan_list:
			self.send(403, chan, ':No such channel') # XXX
			# self.send(324, chan, mode_str, *mode_args)
			# if not topic: self.send(331, chan, ':No topic is set')
			# else:
			# 	self.send(332, chan, ':XXX: channel topic here')
			# 	self.send(333, chan, nick, set_at_unix_timestamp) # after 332
			# # See https://modern.ircdocs.horse/#rplnamreply-353
			# for name in names.chunks(512-cmd-len):
			# 	self.send(353, '=', chan, :[prefix]<nick>{ [prefix]<nick>})
			# self.send(366, chan, ':End of /NAMES list')

	def recv_cmd_part(self, chan, reason=None):
		chan_list = chan.split(',')
		for chan in chan_list:
			self.send(403, chan, ':No such channel') # XXX
			# if chan not in ...: self.send(403, chan, ':No such channel')
			# if chan in self.st.chan_set: self.send(f'PART {chan}')
			# else: self.send(442, chan, ':You are not on that channel')

	def recv_cmd_topic(self, chan, topic=None):
		self.send(403, chan, ':No such channel') # XXX
		# topic = ...
		# if not topic: self.send(331, chan, ':No topic is set')
		# else: # XXX: may return 442 if it's hard to fetch
		# 	self.send(332, chan, ':XXX: channel topic here')
		# 	self.send(333, chan, nick, set_at_unix_timestamp) # after 332

	def recv_cmd_names(self, chan):
		chan_list = chan.split(',')
		for chan in chan_list:
			self.send(403, chan, ':No such channel') # XXX
			# # See https://modern.ircdocs.horse/#rplnamreply-353
			# for name in names.chunks(512-cmd-len):
			# 	self.send(353, '=', chan, :[prefix]<nick>{ [prefix]<nick>})
			# self.send(366, chan, ':End of /NAMES list')

	def recv_cmd_list(self, chan=None, cond=None):
		# XXX: searching for new channels (ELIST=C) might be nice to have
		self.send(321, 'Channel :Users  Name')
		for c in self.discord_chans: self.send(322, c.name, c.users, ':{c.topic}')
		self.send(321, ':End of /LIST')

	def recv_cmd_motd(self, target=None): self.send_motd()

	def recv_cmd_version(self, target=None):
		# XXX: also send RPL_ISUPPORT here
		self.send(351, self.bridge.server_ver, 'rdircd', ':rdircd discord-to-irc bridge')

	# XXX: more server info commands
	# def recv_cmd_admin(self):
	# def recv_cmd_connect(self):
	# def recv_cmd_time(self):
	# def recv_cmd_stats(self):
	# def recv_cmd_info(self):
	# def recv_cmd_mode(self): # https://modern.ircdocs.horse/#mode-message

	# XXX: msg commands
	# def recv_cmd_privmsg(self, target, text): # https://modern.ircdocs.horse/#privmsg-message
	# def recv_cmd_notice(self, target, text):

	def recv_cmd_userhost(self, nick):
		if str_norm(nick) == str_norm(self.st.nick):
			self.send(302, f':{nick}=+~{self.st.user}@{self.st.host}')
		else: self.send(401, nick, ':No such nick/channel') # XXX: info for discord nicks

	# def recv_cmd_whois(self, nick): # XXX: RPL_*WHOIS* + discord info via notices?



class DiscordError(Exception): pass

class Discord:

	api_url = 'https://discordapp.com/api/v6'

	def __init__(self, loop, conf):
		self.loop, self.conf = loop, conf
		self.log = get_logger('rdircd.discord')

	async def __aenter__(self):
		await self.fill_in_client_creds()
		return self
	async def __aexit__(self, *err): pass

	async def fill_in_client_creds(self):
		def stdin_line_reader(fut):
			self.loop.remove_reader(sys.stdin.fileno())
			fut.set_result(sys.stdin.readline())
		async def read_stdin_line():
			input_line = asyncio.Future()
			self.loop.add_reader(sys.stdin.fileno(), stdin_line_reader, input_line)
			return (await input_line).strip() or ''
		if not self.conf.discord_client_id:
			print('\n'.join([ '',
				'There is no "client-id" specified under "[discord]"',
				f'  section of the config file ({self.conf._conf_path}).',
				'Go to following URL via browser:',
				'  https://discordapp.com/developers/applications/#top',
				'Register app there, in OAuth2 tab find'
				'  "Client ID" (big number) and copy-paste it below.',
				'Client ID: ' ]), end='')
			while True:
				client_id = await read_stdin_line()
				if client_id.isdigit() and len(client_id) > 10: break
				print('\n'.join([
					f'!!! ERROR: Entered client ID looks bogus - {client_id!r}',
					'Client ID: ' ]), end='')
			self.conf.discord_client_id = client_id
			self.conf.update_file_section('discord', 'client_id')
			print(f'--- Discord Client ID stored in config file: {self.conf._conf_path}')
		for acc in 'main', 'ghost':
			k = f'auth_{acc}_code'
			if self.conf.get(k): continue
			print('\n'.join([ '',
				f'Filling-in auth code value for **{acc.upper()}** account.',
				'Go to following URL via browser:',
				'  ' 'https://discordapp.com/api/oauth2/authorize?'
					f'client_id={self.conf.discord_client_id}&redirect_uri=https%3A%2F%2Flocalhost'
					'&response_type=code&scope=messages.read',
				'Discord will ask whether app should be authorized'
				'  for access and redirect to some localhost URL after that.',
				'Copy-paste that final redirect-to URL below.',
				f'IMPORTANT: do this after logging into {acc.upper()} account.',
				*([] if acc == 'main' else [f'Leave empty to not use additional {acc} account.']),
				'Redirect-to URL: ' ]), end='')
			while True:
				url = await read_stdin_line()
				if acc != 'main' and not url:
					code = 'nx'
					break
				try:
					if not re.search(r'https?://.*?\?.*\bcode=', url):
						raise ValueError('This does not look like an URL')
					parts = urllib.parse.urlparse(url)
					qs = urllib.parse.parse_qs(parts.query)
					code = qs['code'][-1]
				except Exception as err:
					print('\n'.join([
						f'!!! ERROR: Entered redirect URL looks bogus - {url!r}',
						f'!!! ERROR: Specific error - {err_fmt(err)}',
						'Redirect-to URL: ' ]), end='')
					continue
				else: break
			self.conf.set(k, code)
			self.conf.update_file_section('auth', k)
			if code != 'nx':
				print(f'--- Discord Auth Code stored in config file: {self.conf._conf_path}')
			else:
				print(f'--- Additional {acc} account will be disabled')
				print(f'--- Remove "{acc}_code = nx" line from "[auth]" section to enable it')



class RDIRCD:

	def __init__(self, loop, conf):
		self.loop, self.conf = loop, conf
		self.log = get_logger('rdircd.bridge')

	async def __aenter__(self):
		self.server_ver = '1.0.0'
		self.server_ts = dt.datetime.utcnow()
		self.server_host = os.uname().nodename
		self.irc_conns, self.irc_conns_max = dict(), 0
		return self
	async def __aexit__(self, *err): pass

	async def run(self):
		ircd = await self.loop.create_server(
			IRCProtocol.factory_for_bridge(self),
			self.conf.irc_host, self.conf.irc_port,
			family=self.conf.irc_host_af, start_serving=False )
		async with Discord(self.loop, self.conf) as discord:
			# XXX: pass self to discord for control hooks and events
			await ircd.serve_forever()

	async def run_async(self):
		async with self: await self.run()

	def irc_conn_new(self, irc):
		self.irc_conns[id(irc)] = irc
		self.irc_conns_max = max(self.irc_conns_max, len(self.irc_conns))
	def irc_conn_lost(self, irc): self.irc_conns.pop(id(irc), None)
	def irc_conn_stats(self):
		stats = adict(
			servers=1, chans=0, # XXX: number of servers/chans from discord
			total=0, total_max=self.irc_conns_max, unknown=0, auth=0, op=0 )
		for conn in self.irc_conns.values():
			stats.total += 1
			if conn.st.auth: stats.auth += 1
			else: stats.unknown += 1
		return stats



class RDIRCDConfig:

	irc_host = '127.0.0.1'
	irc_port = 6667
	irc_password = ''
	irc_host_af = 0

	discord_client_id = ''

	auth_main_code = ''
	auth_main_token = ''
	auth_main_token_refresh = ''
	auth_ghost_code = ''
	auth_ghost_token = ''
	auth_ghost_token_refresh = ''

	# XXX: options for well-timestamped protocol logs

	_conf_path = '~/.rdircd.ini'
	_conf_sections = 'irc', 'discord', 'auth'

	def __repr__(self): return repr(vars(self))
	def get(self, *k): return getattr(self, '_'.join(k))
	def set(self, k, v): setattr(self, k, v)

	def pprint(self, title=None):
		cat, chk = None, re.compile(
			'^({})_(.*)$'.format('|'.join(map(re.escape, self._conf_sections))) )
		if title: print(f';; {title}')
		for k in sorted(dir(self)):
			m = chk.search(k)
			if not m: continue
			if m.group(1) != cat:
				cat = m.group(1)
				print(f'\n[{cat}]')
			v = self.get(k)
			if isinstance(v, bool): v = ['no', 'yes'][v]
			k = m.group(2).replace('_', '-')
			print(f'{k} = {v}')

	def update_from_file(self, config, section='default', prefix=None):
		for k in dir(self):
			if prefix:
				if not k.startswith(prefix): continue
				conf_k, k = k, k[len(prefix):]
			elif k.startswith('_'): continue
			else: conf_k = k
			v = getattr(self, conf_k)
			if isinstance(v, str): get_val = lambda *a: str(config.get(*a, raw=True))
			elif isinstance(v, bool): get_val = config.getboolean
			elif isinstance(v, int): get_val = lambda *a: int(re.sub(r'[ _]', '', config.get(*a)))
			elif isinstance(v, float): get_val = lambda *a: float(config.get(*a))
			else: continue # values with other types cannot be specified in config
			for k_conf in {k, k.replace('_', '-')}:
				try: self.set(conf_k, get_val(section, k_conf))
				except configparser.NoSectionError: pass
				except configparser.NoOptionError: pass

	def update_file_section(self, section, keys=None, path=None):
		if not path: path = self._conf_path
		if isinstance(path, str): path = pl.Path(path)
		sec_re, sec_k = re.compile(r'(?i)^\[\s*(\S+)\s*\]$'), str_norm(section)
		sec_prefix = section.lower().replace('-', '_') + '_'
		if not keys: keys = list(k for k in vars(self).keys() if k.startswith(sec_prefix))
		if isinstance(keys, str): keys = keys.split()
		for n, k in enumerate(keys):
			if not k.startswith(sec_prefix): k = sec_prefix + k
			k, v = k[len(sec_prefix):].replace('_', '-'), self.get(k)
			if isinstance(v, bool): v = ['no', 'yes'][v]
			keys[n] = k, v, re.compile(r'(?i)^' + k.replace('-', '[-_]') + r'\s*=')
		keys = dict((k, (v, rx)) for k, v, rx in keys)
		with path.open() as src, safe_replacement(path) as dst:
			lines, sec, sec_parse = list(), list(), False
			for n, line in enumerate(src):
				m, line = sec_re.search(line.strip()), line.rstrip()
				if m:
					k = str_norm(m.group(1))
					if k == sec_k:
						sec_parse = True
						if sec: line = '' # drop duplicate headers
					if k != sec_k: sec_parse = False
				if sec_parse: sec.append(line)
				else: lines.append(line)
			while sec and not sec[-1]: sec.pop()
			if not sec: sec.append(f'[{section}]')
			if lines and lines[-1]: lines.append('')
			for line in lines: dst.write(f'{line}\n')
			for n, line in enumerate(sec):
				for k, (v, rx) in keys.items():
					if not rx.search(line): continue
					if v is None: line = None
					else: line, keys[k] = f'{k} = {v}', (None, rx)
				if line is not None: dst.write(f'{line}\n')
			for k, (v, rx) in keys.items():
				if v is None: continue
				dst.write(f'{k} = {v}\n')



def main(args=None, conf=None):
	if not conf: conf = RDIRCDConfig()

	import argparse, textwrap
	dedent = lambda text: (textwrap.dedent(text).strip('\n') + '\n').replace('\t', '  ')
	text_fill = lambda s,w=100,ind='\t',ind_next=None,**k: textwrap.fill(
		s, w, initial_indent=ind, subsequent_indent=ind if ind_next is None else ind_next, **k )
	class SmartHelpFormatter(argparse.HelpFormatter):
		def __init__(self, *args, **kws):
			return super().__init__(*args, **kws, width=100)
		def _fill_text(self, text, width, indent):
			if '\n' not in text: return super()._fill_text(text, width, indent)
			return ''.join( indent + line
				for line in text.replace('\t', '  ').splitlines(keepends=True) )
		def _split_lines(self, text, width):
			return super()._split_lines(text, width)\
				if '\n' not in text else dedent(text).splitlines()

	parser = argparse.ArgumentParser(
		formatter_class=SmartHelpFormatter,
		description='Reliable personal discord-client to irc-server translation daemon.')

	group = parser.add_argument_group('Configuration file(s)')
	group.add_argument('-c', '--conf',
		metavar='file', action='append',
		help=f'''
			Path to configuration file to use.
			It will get updated with OAuth2 credentials
				(only adding or changing [auth] section), so has to be writable.
			Default: {conf._conf_path}''')
	group.add_argument('--conf-dump', action='store_true',
		help='Print all configuration settings, which will be used with'
			' currently detected (and/or specified) configuration file(s), and exit.')
	group.add_argument('--conf-dump-defaults', action='store_true',
		help='Print all default settings, which would be used'
			' if no configuration file(s) were overriding these, and exit.')

	group = parser.add_argument_group('Interfaces')
	group.add_argument('-i', '--irc-bind', metavar='host(:port)',
		help=f'''
			Address/host (to be resolved via gai) and port to bind IRC server to.
			When specifying port after raw IPv6 address,
				enclose the latter in [], for example - [::]:6667.
			Default: {conf.irc_host}:{conf.irc_port} or whatever is in --conf file.''')

	parser.add_argument('-d', '--debug', action='store_true', help='Verbose operation mode.')
	opts = parser.parse_args(sys.argv[1:] if args is None else args)

	if opts.conf_dump_defaults:
		conf.pprint('Default configuration options')
		return

	conf_file = configparser.ConfigParser(allow_no_value=True)
	conf_user_paths = list(map(
		os.path.expanduser, opts.conf or [conf._conf_path] ))
	for n, p in enumerate(conf_user_paths):
		mode = os.R_OK
		if n == len(conf_user_paths) - 1: mode |= os.W_OK
		if not os.access(p, mode):
			parser.error(f'Specified config file missing or inaccessible: {p}')
	conf_file.read(conf_user_paths)
	for k in conf._conf_sections:
		conf.update_from_file(conf_file, section=k, prefix=f'{k}_')
	conf._conf_path = conf_user_paths[-1]

	if opts.conf_dump:
		conf.pprint('Current configuration options')
		return

	log_fmt = '%(name)s %(levelname)5s :: %(message)s'
	if opts.debug: log_fmt = '%(asctime)s :: ' + log_fmt
	log_fmt = logging.Formatter(log_fmt)
	log_handler = logging.StreamHandler(sys.stderr)
	log_handler.setLevel(logging.DEBUG if opts.debug else logging.WARNING)
	log_handler.setFormatter(log_fmt)
	logging.root.addHandler(log_handler)
	logging.root.setLevel(0)
	log = get_logger('main')

	host, port, family = opts.irc_bind or conf.irc_host, conf.irc_port, conf.irc_host_af
	if host.count(':') > 1: host, port = str_part(host, ']:>', port)
	else: host, port = str_part(host, ':>', port)
	if '[' in host: family = socket.AF_INET6
	host, port = host.strip('[]'), int(port)
	try:
		addrinfo = socket.getaddrinfo( host, str(port),
			family=family, type=socket.SOCK_STREAM, proto=socket.IPPROTO_TCP )
		if not addrinfo: raise socket.gaierror('No addrinfo for host: {}'.format(host))
	except (socket.gaierror, socket.error) as err:
		parser.error( 'Failed to resolve irc socket parameters (address, family)'
			' via getaddrinfo: {!r} - [{}] {}'.format((host, port), err.__class__.__name__, err) )
	sock_af, sock_t, sock_p, _, sock_addr = addrinfo[0]
	log.debug(
		'Resolved irc host:port {!r}:{!r} to endpoint: {} (family: {}, type: {}, proto: {})',
		host, port, sock_addr, *(sockopt_resolve(pre, n)
			for pre, n in [('af_', sock_af), ('sock_', sock_t), ('ipproto_', sock_p)]) )
	assert ( sock_t == socket.SOCK_STREAM
		and sock_p == socket.IPPROTO_TCP ), [sock_t, sock_p]
	conf.irc_host_af, (conf.irc_host, conf.irc_port) = sock_af, sock_addr[:2]

	log.debug('Starting eventloop...')
	with contextlib.closing(asyncio.get_event_loop()) as loop:
		# if opts.debug: loop.set_debug(True)
		rdircd = RDIRCD(loop, conf)
		rdircd_task = loop.create_task(rdircd.run_async())
		for sig in 'INT TERM'.split():
			loop.add_signal_handler(getattr(signal, f'SIG{sig}'), rdircd_task.cancel)
		try: return loop.run_until_complete(rdircd_task)
		except asyncio.CancelledError: pass
	log.debug('Finished')

if __name__ == '__main__': sys.exit(main())
