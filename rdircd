#!/usr/bin/env python3

import itertools as it, operator as op, functools as ft
import os, sys, io, stat, logging, re, time, secrets, hashlib, enum, json
import contextlib, asyncio, socket, signal, inspect, unicodedata, urllib.parse
import configparser, tempfile, datetime as dt, collections as cs, pathlib as pl

import aiohttp


err_fmt = lambda err: '[{}] {}'.format(err.__class__.__name__, err)

class LogMessage:
	def __init__(self, fmt, a, k): self.fmt, self.a, self.k = fmt, a, k
	def __str__(self): return self.fmt.format(*self.a, **self.k) if self.a or self.k else self.fmt

class LogStyleAdapter(logging.LoggerAdapter):
	def __init__(self, logger, extra=None):
		super(LogStyleAdapter, self).__init__(logger, extra or {})
	def log(self, level, msg, *args, **kws):
		if not self.isEnabledFor(level): return
		log_kws = {} if 'exc_info' not in kws else dict(exc_info=kws.pop('exc_info'))
		msg, kws = self.process(msg, kws)
		self.logger._log(level, LogMessage(msg, args, kws), (), **log_kws)

class LogFuncHandler(logging.Handler):
	def __init__(self, func):
		super().__init__()
		self.func, self.locked = func, False
	def emit(self, record):
		if self.locked: return # to avoid logging-of-logging loops, assuming sync call
		self.locked = True
		try: self.func(self.format(record))
		except Exception: self.handleError(record)
		finally: self.locked = False

get_logger = lambda name: LogStyleAdapter(logging.getLogger(name))

def str_part(s, sep, default=None):
	'Examples: str_part("user@host", "<@", "root"), str_part("host:port", ":>")'
	c = sep.strip('<>')
	if sep.strip(c) == '<': return (default, s) if c not in s else s.split(c, 1)
	else: return (s, default) if c not in s else s.rsplit(c, 1)

def sockopt_resolve(prefix, v):
	prefix = prefix.upper()
	for k in dir(socket):
		if not k.startswith(prefix): continue
		if getattr(socket, k) == v: return k[len(prefix):]
	return v

class adict(dict):
	def __init__(self, *args, **kws):
		super().__init__(*args, **kws)
		self.__dict__ = self
		for k, v in self.items():
			if type(v) is dict: self[k] = adict(v)

def iter_gather(cls):
	def _cls_wrapper(func):
		@ft.wraps(func)
		def _wrapper(*args, **kws): return cls(func(*args, **kws))
		return _wrapper
	return _cls_wrapper

str_norm = lambda v: unicodedata.normalize('NFKC', v.strip()).casefold()

@contextlib.contextmanager
def safe_replacement(path, *open_args, mode=None, **open_kws):
	path = str(path)
	if mode is None:
		try: mode = stat.S_IMODE(os.lstat(path).st_mode)
		except OSError: pass
	open_kws.update( delete=False,
		dir=os.path.dirname(path), prefix=os.path.basename(path)+'.' )
	if not open_args: open_kws['mode'] = 'w'
	with tempfile.NamedTemporaryFile(*open_args, **open_kws) as tmp:
		try:
			if mode is not None: os.fchmod(tmp.fileno(), mode)
			yield tmp
			if not tmp.closed: tmp.flush()
			os.rename(tmp.name, path)
		finally:
			try: os.unlink(tmp.name)
			except OSError: pass

def token_bucket(spec, negative_tokens=False):
	'''Spec: { interval_seconds: float | float_a/float_b }[:burst_float]
			Examples: 1/4:5 (interval=0.25s, rate=4/s, burst=5), 5, 0.5:10, 20:30.
		Expects a number of tokens (can be float, default: 1)
			and *always* subtracts these.
		Yields either None if there's enough
			tokens or delay (in seconds, float) until when there will be.'''
	try:
		try: interval, burst = spec.rsplit(':', 1)
		except (ValueError, AttributeError): interval, burst = spec, 1.0
		else: burst = float(burst)
		if isinstance(interval, str):
			try: a, b = interval.split('/', 1)
			except ValueError: interval = float(interval)
			else: interval = float(a) / float(b)
		if min(interval, burst) < 0: raise ValueError()
	except: raise ValueError('Invalid format for rate-limit: {!r}'.format(spec))
	# log.debug('tbf parameters: interval={:.1f}, burst={:.1f}', interval, burst)
	tokens, rate, ts_sync = burst, interval**-1, time.monotonic()
	val = (yield) or 1
	while True:
		ts = time.monotonic()
		ts_sync, tokens = ts, min(burst, tokens + (ts - ts_sync) * rate)
		val, tokens = (None, tokens - val) if tokens >= val else\
			((val - tokens) / rate, (tokens - val) if negative_tokens else tokens)
		val = (yield val) or 1

async def await_wrap(res):
	if inspect.isawaitable(res): res = await res
	return res

async def task_cancel_list(task_list):
	task_list = list(task for task in task_list if task and not task.done())
	for task in task_list:
		with contextlib.suppress(asyncio.CancelledError): task.cancel()
	for task in task_list:
		with contextlib.suppress(asyncio.CancelledError): await task

class StacklessContext:
	'''Like AsyncContextStack, but for tracking tasks that
		can finish at any point without leaving stack frames.'''

	def __init__(self): self.tasks = dict()
	async def __aenter__(self): return self
	async def __aexit__(self, *err):
		if self.tasks:
			task_list, self.tasks = self.tasks.values(), None
			await task_cancel_list(task_list)
	async def close(self): await self.__aexit__(None, None, None)

	def add_task(self, coro, run_after=None):
		'Start task eating its own tail, with an optional success-only callback'
		task_id = None
		async def _task_wrapper(coro=coro):
			try:
				await coro
				if run_after:
					coro = run_after()
					if asyncio.iscoroutine(coro): await coro
			# except TypeError:
			# 	print('----- coro', coro, file=sys.stderr)
			# 	raise
			finally:
				assert task_id is not None, task_id
				if self.tasks: self.tasks.pop(task_id, None)
		task = asyncio.create_task(_task_wrapper())
		task_id = id(task)
		self.tasks[task_id] = task
		return task
	add = add_task



class IRCProtocolError(Exception): pass
class IRCProtocolArgsError(IRCProtocolError): pass

class IRCProtocol:

	# Extensive lists of modes are copied from freenode to make clients happy
	feats_modes = 'DOQRSZaghilopswz CFILMPQSbcefgijklmnopqrstvz'
	feats_support = ( 'AWAYLEN=200 CASEMAPPING=ascii'
		' CHANLIMIT=#:512 CHANTYPES=# CHANMODES=eIbq,k,flj,CFLMPQScgimnprstz'
		' CHANNELLEN=80 ELIST=C NETWORK=rdircd NICKLEN=64'
		' PREFIX=(ov)@+ SAFELIST STATUSMSG=@+ TOPICLEN=390 USERLEN=32' ).split()

	@classmethod
	def factory_for_bridge(cls, rdircd):
		def _wrapper():
			try: return cls(rdircd)
			except Exception as err:
				log = get_logger('rdircd.irc')
				log.exception('Failed to initialize ircd protocol: {}', err_fmt(err))
				log.critical('Stopping daemon due to unhandled protocol error')
				loop.stop()
		return _wrapper

	def __init__(self, rdircd):
		self.bridge, self.loop, self.conf = rdircd, rdircd.loop, rdircd.conf
		self.log = get_logger('rdircd.irc')
		self.transport, self.buff = None, b''
		self.st = adict(
			nick=None, user=None, pw=None, pw_hash=None,
			host=None, auth=False, cap_neg=False, chans=set() )
		if self.conf.irc_password:
			salt = os.urandom(8)
			self.st.pw_hash = salt, hashlib.blake2b(
				self.conf.irc_password.encode(), salt=salt ).digest()


	def connection_made(self, tr):
		host, port = tr.get_extra_info('peername')[:2]
		self.log.debug('Connection from {}', host)
		self.transport, self.st.host = tr, host
		self.send('NOTICE * :*** rdircd ready')
		self.bridge.irc_conn_new(self)

	def data_received(self, data):
		self.buff += data
		while b'\n' in self.buff:
			line, self.buff = self.buff.split(b'\n', 1)
			line_len, line_repr = self._repr(line, True)
			self.log.debug('<<  [{} {}] {}', self.st.nick or '---', line_len, line_repr)
			if not line.strip(): continue
			self.recv(line)

	def eof_received(self): pass
	def connection_lost(self, err):
		self.log.debug('Connection lost: {}', err or 'closed cleanly')
		self.bridge.irc_conn_lost(self)

	def data_send(self, data):
		data_len, data_repr = self._repr(data, True)
		self.log.debug(' >> [{} {}] {}', self.st.nick or '---', data_len, data_repr)
		self.transport.write(data)


	def _repr(self, data, prefix=False, max_len=99, ext=' [{data_len}]'):
		if isinstance(data, str): data = data.encode()
		data_len, data_repr, ext_len = f'{len(data):03,d}', repr(data)[2:-1], len(ext)
		if len(data_repr) > max_len:
			data_len = f'{max_len}/{data_len}'
			data_repr = data_repr[:max_len - ext_len] + ext.format(data_len=data_len)
		return (data_len, data_repr) if prefix else data_repr

	def _parse(self, line):
		if isinstance(line, bytes): line = line.decode()
		m = adict(line=line, params=list())
		for k in '@tags', ':src':
			pre, k = k[0], k[1:]
			if line.startswith(pre):
				try: m[k], line = line.split(' ', 1)
				except ValueError:
					raise IRCProtocolLineError(line) from None
				line = line.lstrip(' ')
			else: m[k] = None
		while True:
			if line.startswith(':'):
				m.params.append(line[1:])
				break
			if ' ' in line:
				param, line = line.split(' ', 1)
				line = line.lstrip(' ')
			else: param, line = line, ''
			m.params.append(param)
			if not line: break
		if m.params: m.cmd, m.params = m.params[0].lower(), m.params[1:]
		else: raise IRCProtocolLineError(line)
		return m

	def send(self, line_or_code, *args, max_len=450, auto_split=True):
		line = line_or_code
		if isinstance(line, int): line = f'{line:03d} {self.st.nick or "*"}'
		if args: line += ' ' + ' '.join(map(str, args))
		if isinstance(line, str): line = line.encode()
		line = line.rstrip(b'\r\n')
		if b'\n' in line or len(line) > max_len:
			if auto_split:
				m = self._parse(line)
				if m.cmd == 'privmsg': return self.send_split_privmsg(m)
			if len(line) > max_len:
				self.log.warning('Sending line with >{}B: {!r}', max_len, self._repr(line))
		line += b'\r\n'
		self.data_send(line)

	def send_split_privmsg(self, m, max_len=300):
		dst, line = m.params
		pre = f'{m.cmd.upper()} {dst}'
		if m.src: pre = f'{m.src} {pre}'
		if '\n' in line:
			for line in line.split('\n'): self.send(pre, f':{line.rstrip()}')
			return
		line, ws = '', re.findall(r'(\S+)(\s*)', line)
		for w, sep in ws:
			if line.strip() and len(line) + len(w) > max_len:
				self.send(pre, f':{line.rstrip()}', auto_split=False)
				line = sep_last
			sep_last, line = sep, line + w + sep
		if line.strip(): self.send(pre, f':{line.rstrip()}', auto_split=False)

	def recv(self, line_raw, _cmd_cache=dict()):
		if isinstance(line_raw, str): line = line_raw
		else:
			try: line = line_raw.decode().strip()
			except UnicodeDecodeError:
				return self.log.error('Failed to decode line as utf-8: {!r}', self._repr(line_raw))
		try: m = self._parse(line)
		except IRCProtocolLineError:
			return self.log.error('Line protocol error: {!r}', self._repr(line_raw))
		cmd_cache = _cmd_cache.get(m.cmd)
		if cmd_cache: cmd_func, cmd_ps_n = cmd_cache
		else:
			cmd_func, cmd_ps_n = getattr(self, f'recv_cmd_{m.cmd}', None), 0
			if cmd_func:
				args = list(inspect.signature(cmd_func).parameters.values())
				cmd_ps_n = len(args)
				if cmd_ps_n == 1 and args[0].annotation == 'msg': cmd_ps_n = None
				else: cmd_ps_n = cmd_ps_n - sum(1 for p in args if p.default is not p.empty), cmd_ps_n
			_cmd_cache[m.cmd] = cmd_func, cmd_ps_n
		if not cmd_func:
			self.log.error('Unhandled cmd: {!r}', self._repr(line_raw))
			return self.send(421, ':Unknown command')
		if not self.check_access(m.cmd):
			return self.log.error('Out-of-order cmd: {!r}', self._repr(line_raw))
		if cmd_ps_n is None: cmd_func(m)
		else:
			(a, b), n = cmd_ps_n, len(m.params)
			if not a <= n <= b:
				self.log.error( 'Command/args'
					' mismatch [{} vs {}-{}]: {!r}', n, a, b, self._repr(line) )
				return self.send(461, ':Incorrect command parameters')
			try: cmd_func(*m.params)
			except Exception as err:
				self.send(400, m.cmd.upper(), f':BUG - Internal Error - {err_fmt(err)}')
				self.log.exception('Error processing message: {}', m)

	def check_access(self, cmd):
		if self.st.cap_neg: return cmd in ['cap', 'quit']
		if not self.st.auth:
			res = cmd in ['cap', 'user', 'nick', 'pass', 'quit', 'ping']
			if not res: self.send(451, ':You have not registered')
			return res
		res = cmd not in ['user', 'pass']
		if not res: self.send(462, ':You may not reregister')
		return res

	def recv_cmd_ping(self, server, server_dst=None):
		self.send(f'PONG {self.bridge.server_host}')

	def recv_cmd_cap(self, sub, caps=''):
		sub = sub.lower()
		if sub == 'ls':
			self.send('CAP * LS :')
			if caps == '302': self.st.cap_neg = True
		elif sub == 'list': self.send('CAP * LIST :')
		elif sub == 'req':
			self.st.cap_neg = True
			reject = set(c for c in caps.split() if not c.startswith('-'))
			if reject: self.send(f'CAP * NAK :{caps}')
			else: self.send(f'CAP * ACK :{caps}')
		elif sub == 'end': self.st.cap_neg = False

	def recv_cmd_pass(self, pw):
		self.st.pw = pw
		self.check_auth_done()
	def recv_cmd_user(self, name, a, b, real_name):
		self.st.update(user=name, real_name=real_name)
		self.check_auth_done()
	def recv_cmd_nick(self, nick):
		if not re.search(r'^[a-zA-Z-._]+$', nick):
			return self.send(432, nick, ':Erroneus nickname')
		if self.bridge.cmd_conn(nick):
			return self.send(433, nick, ':Nickname is already in use')
		self.st.nick = nick
		if self.st.auth and self.st.nick:
			self.send(f':{self.st.nick} NICK {nick}')
		self.check_auth_done()

	def check_auth_done(self):
		# Delay is to avoid trivial bruteforcing
		self.bridge.cmd_delay('irc_auth', self.check_auth_done_delayed)

	def check_auth_done_delayed(self):
		if self.st.auth: return
		if not (self.st.nick and self.st.user): return
		if self.st.pw_hash:
			salt, pw_hash = self.st.pw_hash
			if not secrets.compare_digest( pw_hash,
					hashlib.blake2b((self.st.pw or '').encode(), salt=salt).digest() ):
				return self.send(464, ':Password incorrect')
		self.st.auth = True
		self.send('NOTICE * :*** registration completed')
		self.send(1, f':Welcome to the rdircd discord-irc bridge, {self.st.nick}')
		self.send(2,
			f':Your host is {self.bridge.server_host},'
			f' running rdircd {self.bridge.server_ver}' )
		self.send(3, ':This server was created at {}'.format(
			self.bridge.server_ts.strftime('%Y-%m-%d %H:%M:%S UTC') ))
		self.send(4, f'{self.bridge.server_host} rdircd-{self.bridge.server_ver} {self.feats_modes}')
		self.send_feats()
		self.send_stats()
		self.send_motd()

	def send_feats(self, msg_feats_max=10, msg_len_max=200):
		feat_line, ext = list(), ':are supported by this server'
		for feat in it.chain(self.feats_support, [None]):
			if feat: feat_line.append(feat)
			n, msg_len = len(feat_line), sum((len(f)+1) for f in feat_line)
			if feat_line and (not feat or n >= msg_feats_max or msg_len >= msg_len_max):
				self.send(5, ' '.join(feat_line), ext)
				feat_line.clear()

	def send_stats(self):
		s = self.bridge.irc_conn_stats()
		self.send(251, f':There are {s.auth} users and 0 invisible on {s.servers} server(s)')
		self.send(252, f'{s.op} :IRC Operators online')
		self.send(253, f'{s.unknown} :unknown connection(s)')
		self.send(254, f'{s.chans} :channels formed')
		self.send(255, f':I have {s.total} client(s) and {s.servers} server(s)')
		self.send( 265, f'{s.total} {s.total_max}',
			f':Current local users {s.total}, max {s.total_max}' )
		self.send( 266, f'{s.total} {s.total_max}',
			f':Current global users {s.total}, max {s.total_max}' )

	def send_motd(self): self.send(422, ':MOTD File is missing')

	def recv_cmd_quit(self, reason=None):
		self.send('QUIT :Client quit')
		self.send('ERROR :Closing connection (client quit)')
		self.transport.close()

	def req_chan_info(self, chan, cm=None):
		if not chan.startswith('#'):
			self.send(403, chan, ':No such channel')
			return
		if not cm: cm = self.bridge.cmd_chan_map()
		c = cm.get(chan[1:])
		if not c: self.send(403, chan, ':No such channel')
		return c

	def recv_cmd_join(self, chan, key=None):
		if chan == '0': return self.recv_cmd_part(','.join(self.st.chans))
		chan_list, chan_map = chan.split(','), self.bridge.cmd_chan_map()
		for chan in chan_list:
			c = self.req_chan_info(chan, cm=chan_map)
			if not c: continue
			self.send(f':{self.st.nick} JOIN {chan}')
			self.send_topic(chan, c=c)
			self.send_names(chan, own=True, c=c)
			self.st.chans.add(c.name)

	def recv_cmd_part(self, chan, reason=None):
		chan_list, chan_map = chan.split(','), self.bridge.cmd_chan_map()
		for chan in chan_list:
			c = self.req_chan_info(chan, cm=chan_map)
			if not c: continue
			if c.name not in self.st.chans:
				self.send(442, chan, ':You are not on that channel')
			else:
				self.st.chans.remove(c.name)
				self.send(f'PART {chan}')

	def recv_cmd_topic(self, chan, topic=None):
		if not topic: self.send_topic(chan)
		else: self.send(482, chan, ':You are not channel operator')

	def send_topic(self, chan, c=None):
		if not c: c = self.req_chan_info(chan)
		if not c: return
		if not c.topic: self.send(331, chan, ':No topic is set')
		else:
			self.send(332, chan, f':{c.topic}')
			topic_src = c.get('topic_src')
			if topic_src: self.send(333, chan, topic_src.nick, int(topic_src.ts))

	def recv_cmd_names(self, chan):
		chan_list = chan.split(',')
		for chan in chan_list: self.send_names(chan)

	def send_names(self, chan, own=False, c=None, msg_len_max=200):
		if not c: c = self.req_chan_info(chan)
		if not c: return
		name_line = list()
		for name in it.chain(c.names, [None]):
			if name:
				if name == self.st.nick: own = False
				name_line.append(name)
			elif own: name_line.append(self.st.nick)
			if name_line and (
					not name or sum(len(n)+1 for n in name_line) > msg_len_max ):
				self.send(353, '=', chan, ':' + ' '.join(name_line))
				name_line.clear()
		self.send(366, chan, ':End of /NAMES list')

	def recv_cmd_mode(self, target, mode=None, mode_args=None):
		if target.startswith('#'):
			chan = target
			c = self.req_chan_info(chan)
			if not c: return
			self.send(324, chan, '+cnrt')
			self.send(329, chan, int(c.ts_created))
		else:
			if target != self.st.nick:
				self.send(502, ':No access to modes of other users')
				return
			self.send(221, ':+w')

	def recv_cmd_list(self, chan=None, cond=None):
		# XXX: searching for new channels (ELIST=C) might be nice to have
		self.send(321, 'Channel :Users  Name')
		for c in self.bridge.cmd_chan_map().values():
			self.send(322, f'#{c.name}', len(c.names), f':{c.topic}')
		self.send(321, ':End of /LIST')

	def recv_cmd_motd(self, target=None): self.send_motd()

	def recv_cmd_version(self, target=None):
		self.send(351, self.bridge.server_ver, 'rdircd', ':rdircd discord-to-irc bridge')
		self.send_feats()

	def recv_cmd_userhost(self, nick):
		if str_norm(nick) == str_norm(self.st.nick):
			self.send(302, f':{nick}=+~{self.st.user}@{self.st.host}')
		else: self.send(401, nick, ':No such nick/channel') # XXX: info for discord nicks

	# def recv_cmd_whois(self, nick): # XXX: RPL_*WHOIS* + discord info via notices?

	def recv_cmd_privmsg(self, target, text):
		self.cmd_msg(self.st.nick, target, text, skip_self=True)

	def recv_cmd_notice(self, target, text):
		self.cmd_msg(self.st.nick, target, text, notice=True, skip_self=True)

	def cmd_msg(self, src, target, text, notice=False, skip_self=False, msg_type=None):
		# XXX: auto-split long text here
		if not msg_type: msg_type = 'PRIVMSG' if not notice else 'NOTICE'
		if target.startswith('#'):
			chan = target
			if not notice: c = self.req_chan_info(chan)
			else: c = self.bridge.cmd_chan_map().get(chan[1:])
			if not c: return
			for conn in self.bridge.cmd_chan_conns(c.name):
				if skip_self and conn is self: continue
				conn.send(f':{src} {msg_type} {chan} :{text}')
			if not notice and c.name == 'control':
				self.bridge.cmd_control(self, text, chan)
		else:
			conn = self.bridge.cmd_conn(target)
			if not conn:
				if not notice: self.send(401, target, ':No such nick/channel')
			else: conn.send(f':{src} {msg_type} {target} :{text}')

	def cmd_msg_synth(self, src, target, text):
		'Synthetic PRIVMSG which avoids any self-reaction loops like notices'
		return self.cmd_msg(src, target, text, notice=True, msg_type='PRIVMSG')

	# XXX: more server info commands
	# def recv_cmd_admin(self):
	# def recv_cmd_connect(self):
	# def recv_cmd_time(self):
	# def recv_cmd_stats(self):
	# def recv_cmd_info(self):



class DiscordError(Exception): pass
class DiscordAbort(DiscordError): pass
class DiscordHTTPError(DiscordError): pass
class DiscordSessionError(Exception): pass


class Discord:

	def __init__(self, rdircd):
		self.bridge, self.loop, self.conf = rdircd, rdircd.loop, rdircd.conf
		self.log = get_logger('rdircd.discord.main')

	async def __aenter__(self):
		await self.fill_in_client_creds()
		self.sessions = adict()
		for acc in 'main', 'ghost':
			if self.conf.get(f'auth_{acc}_code') == 'nx': continue
			self.sessions[acc] = s = DiscordSession(self, acc)
			s.task = self.loop.create_task(s.run_async())
		return self

	async def __aexit__(self, *err):
		await task_cancel_list(s.task for s in self.sessions.values())

	async def fill_in_client_creds(self):
		# XXX: maybe ask this via irc?
		def stdin_line_reader(fut):
			self.loop.remove_reader(sys.stdin.fileno())
			fut.set_result(sys.stdin.readline())
		async def read_stdin_line():
			input_line = asyncio.Future()
			try:
				self.loop.add_reader(sys.stdin.fileno(), stdin_line_reader, input_line)
				input_line = await input_line
				if not input_line: raise OSError # closed fd
			except OSError:
				print(end='\n\n')
				raise DiscordAbort('Failed to read from stdin') from None
			return input_line.strip() or ''
		if not self.conf.discord_client_id:
			print('\n'.join([ '',
				'There is no "client-id" specified under "[discord]"',
				f'  section of the config file ({self.conf._conf_path}).',
				'Go to following URL via browser:',
				'  https://discordapp.com/developers/applications/#top',
				'Register app there and copy-paste "Client ID" (big number)',
				' and "Client Secret" (alphanumeric) from the main tab there below.',
				'Client ID: ' ]), end='')
			while True:
				client_id = await read_stdin_line()
				if client_id.isdigit() and len(client_id) > 10: break
				print('\n'.join([
					f'!!! ERROR: Entered Client ID looks bogus - {client_id!r}',
					'Client ID: ' ]), end='')
			print('Client Secret: ', end='')
			while True:
				client_secret = await read_stdin_line()
				if len(client_secret) > 20: break
				print('\n'.join([
					f'!!! ERROR: Entered Client Secret looks bogus - {client_secret!r}',
					'Client Secret: ' ]), end='')
			self.conf.discord_client_id = client_id
			self.conf.discord_client_secret = client_secret
			self.conf.update_file_section('discord')
			print(f'--- Discord Client ID/Secret are stored in config file: {self.conf._conf_path}')
		for acc in 'main', 'ghost':
			k = f'auth_{acc}_code'
			if self.conf.get(k): continue
			redirect_url = urllib.parse.quote(self.conf.discord_redirect_url)
			print('\n'.join([ '',
				f'Filling-in auth code value for **{acc.upper()}** account.',
				'Go to following URL via browser:',
				'  ' 'https://discordapp.com/api/oauth2/authorize?'
					f'client_id={self.conf.discord_client_id}&redirect_uri={redirect_url}'
					'&response_type=code&scope=messages.read',
				'Discord will ask whether app should be authorized',
				f'  for access and redirect to {self.conf.discord_redirect_url} URL after that.',
				'Copy-paste that final redirect-to URL below.',
				f'IMPORTANT: do this after logging into {acc.upper()} account, not the other one.',
				*([] if acc == 'main' else [f'Leave empty to not use additional {acc} account.']),
				'Redirect-to URL: ' ]), end='')
			while True:
				url = await read_stdin_line()
				if acc != 'main' and not url:
					code = 'nx'
					break
				try:
					if not re.search(r'https?://.*?\?.*\bcode=', url):
						raise ValueError('This does not look like an URL')
					parts = urllib.parse.urlsplit(url)
					qs = urllib.parse.parse_qs(parts.query)
					code = qs['code'][-1]
				except Exception as err:
					print('\n'.join([
						f'!!! ERROR: Entered redirect URL looks bogus - {url!r}',
						f'!!! ERROR: Specific error - {err_fmt(err)}',
						'Redirect-to URL: ' ]), end='')
					continue
				else: break
			self.conf.set(k, code)
			self.conf.update_file_section('auth', k)
			if code != 'nx':
				print(f'--- Discord Auth Code stored in config file: {self.conf._conf_path}')
			else:
				print(f'--- Additional {acc} account will be disabled')
				print(f'--- Remove "{acc}_code = nx" line from "[auth]" section to enable it')

	def connect(self):
		for s in self.sessions.values(): s.connect()
	def disconnect(self):
		for s in self.sessions.values(): s.disconnect()


class DiscordSession:

	api_ver = 6

	class c(enum.IntEnum):
		dispatch = 0
		heartbeat = 1
		identify = 2
		status_update = 3
		voice_state_update = 4
		resume = 6
		reconnect = 7
		request_guild_members = 8
		invalid_session = 9
		hello = 10
		heartbeat_ack = 11
		unknown_error = 4000
		unknown_opcode = 4001
		decode_error = 4002
		not_authenticated = 4003
		authentication_failed = 4004
		already_authenticated = 4005
		invalid_seq = 4007
		rate_limited = 4008
		session_timeout = 4009
		invalid_shard = 4010
		sharding_required = 4011

	def __init__(self, discord, t):
		self.discord, self.loop, self.conf, self.t = discord, discord.loop, discord.conf, t
		self.api_url = self.conf.discord_api_url.format(api_ver=self.api_ver)
		self.log = get_logger(f'rdircd.discord.{self.t}')

	def get_auth(self, k, default=ValueError):
		try: return getattr(self.conf, f'auth_{self.t}_{k}')
		except AttributeError as err:
			if default is ValueError: raise
			return default

	async def __aenter__(self):
		if not (
				self.conf.discord_client_id
				and self.conf.discord_client_secret
				and self.get_auth('code') ):
			raise DiscordSessionError('Missing client id/secret/code auth credentials')
		self.tasks = StacklessContext()
		self.ws_ctx = self.ws = self.ws_tasks = self.ws_handlers = None
		self.rate_limits, self.seq, self.ws_closed = adict(), None, asyncio.Event()
		return self

	async def __aexit__(self, *err):
		if self.ws_ctx:
			await self.ws_ctx.aclose()
			self.ws_ctx = None
		if self.tasks: await self.tasks.close()

	async def run(self):
		self.log.debug('Starting discord session...')
		try: await asyncio.Future()
		except asyncio.CancelledError: pass
		self.log.debug('Finished')

	async def run_async(self):
		async with self: await self.run()

	async def _connect(self):
		if self.ws_ctx: return
		self.ws_ctx = ctx = contextlib.AsyncExitStack()
		self.ws_tasks, self.ws_handlers = StacklessContext(), dict()
		self.ws_ctx.push_async_callback(self.ws_close)
		self.http = await ctx.enter_async_context(aiohttp.ClientSession())
		self.ws_closed.clear()
		for cache in True, False:
			if cache:
				if not self.conf.auth_gateway: continue
			else:
				self.conf.auth_gateway = (await self.req('gateway', auth=False))['url']
				self.conf.update_file_section('auth', 'auth_gateway')
			parts = adict(urllib.parse.urlsplit(self.conf.auth_gateway)._asdict())
			query = urllib.parse.parse_qs(parts.query)
			query.update(v=str(self.api_ver), encoding='json')
			parts.query = urllib.parse.urlencode(query)
			ws_url = urllib.parse.urlunsplit(tuple(parts.values()))
			try:
				self.ws = await ctx.enter_async_context(self.http.ws_connect( ws_url,
					headers={'User-Agent': self.conf.discord_user_agent},
					heartbeat=self.conf.discord_ws_heartbeat, timeout=self.conf.discord_ws_timeout ))
			except aiohttp.ClientError as err:
				self.log.error('Gateway connection error: {}', err_fmt(err))
				if cache: continue # try fetching new gw url
			else: break
		else: self.ws = None
		if not self.ws: # XXX: more specific error/details, handle wrt reconnect
			self.ws_closed.set()
			raise DiscordSessionError('Failed to connect to discord')
		self.ws_add_handler(self.c.dispatch, self.op_track_seq)
		self.ws_add_handler(self.c.hello, self.op_hello)
		self.ws_tasks.add(self.ws_poller()).add_done_callback(self.ws_poller_done)

	def connect(self):
		# XXX: start reconnect logic/task, report back to irc control
		return self.tasks.add(self._connect())
	def disconnect(self): return self.tasks.add(self.ws_close())


	### Regular HTTP requests and OAuth2 stuff

	async def rate_limit_wrapper(self, route, req_func):
		ts = time.time()
		req_limit, req_limit_ts = self.rate_limits.get(route) or (1, None)
		if req_limit_ts and ts > req_limit_ts: req_limit = 1
		if req_limit <= 0 and req_limit_ts and req_limit_ts > ts:
			delay = req_limit_ts - ts
			self.log.debug('Rate-limiting request on route {!r}: delay={:,.1f}s', route, delay)
			await asyncio.sleep(delay)
		res = await req_func()
		req_limit = res.headers.get('X-RateLimit-Remaining')
		if req_limit:
			self.rate_limits[route] = int(req_limit), res.headers.get('X-RateLimit-Reset')
		return res

	async def req_get_token(self):
		self.log.debug('Requestiing new api auth token')
		scopes = {'messages.read'}
		# Does not work with invalid_grant, will need to fix that if rest-api is needed
		res = await self.req( f'{self.api_url}/oauth2/token',
			m='post', route='auth', auth=False, data=dict(
				client_id=self.conf.discord_client_id,
				client_secret=self.conf.discord_client_secret,
				grant_type='authorization_code',
				code=self.get_auth('code'),
				redirect_uri=self.conf.discord_redirect_url,
				scope=' '.join(scopes) ))
		async with res:
			res.raise_for_status()
			res = adict((await res.json()) or dict())
		try:
			if not all([
					res.access_token, res.refresh_token,
					res.token_type == 'Bearer',
					not scopes.difference(res.scope.split()) ]):
				raise KeyError
		except KeyError:
			raise DiscordSessionError(f'Auth token error: {res}') from None
		setattr(self.conf, f'auth_{self.t}_token', res.access_token)
		setattr(self.conf, f'auth_{self.t}_token_refresh', res.refresh_token)
		self.conf.update_file_section('auth')

	async def req( self, url, *args,
			m='get', route=None, auth=True, raw=False, **kws ):
		if not re.search(r'^https?:', url):
			url = urllib.parse.urljoin(self.api_url, url)
		if route is None: route = url
		kws.setdefault('headers', dict()).setdefault(
			'User-Agent', self.conf.discord_user_agent )
		for att in 'normal', 'token_refresh':
			if auth:
				token = self.get_auth('token', None)
				if not token or att == 'token_refresh': await self.req_get_token()
				kws.setdefault('headers', dict()).update(Authorization=f'Bearer {token}')
			req_func = ft.partial(self.http.request, m, url, *args, **kws)
			self.log.debug('req  >> {} {}', m, url)
			res = await self.rate_limit_wrapper(route, req_func)
			if not auth: break
			if res.status == 401:
				res.release()
				if att != 'normal': raise DiscordSessionError('Auth failed')
		if res.status >= 400:
			body = await res.text()
			raise DiscordHTTPError(f'[{res.status}] {res.reason} - {body}')
		if not raw: res = await res.json()
		self.log.debug('req <<  {}', res)
		return res


	### Gateway Websocket wrappers

	_ws_handler = cs.namedtuple('ws_handler', 'op func')
	def ws_add_handler(self, op=None, func=None):
		if not func: raise ValueError(func)
		self.ws_handlers[id(func)] = self._ws_handler(op, func)

	async def ws_poller(self):
		# {op=0**, s=**42, d={...}, t=**'GATEWAY_EVENT_NAME'}
		# {op=...[, d={...}]}
		async for msg in self.ws:
			if self.conf.discord_ws_debug:
				self.log.debug( 'ws <<  {} {}',
					aiohttp.WSMsgType(msg.type).name.lower(), getattr(msg, 'data', '') )
			if msg.type == aiohttp.WSMsgType.text:
				msg_data, hs_discard = adict(json.loads(msg.data)), set()
				for k, h in self.ws_handlers.items():
					# XXX: use op and other checks as ws_handler keys
					if h.op is not None and msg_data.op != h.op: continue
					oneshot = await await_wrap(h.func(msg_data))
					if oneshot: hs_discard.add(k)
				for k in hs_discard: del self.ws_handlers[k]
			elif msg.type == aiohttp.WSMsgType.closed: break
			elif msg.type == aiohttp.WSMsgType.error:
				self.log.error('ws protocol error, aborting: {}', msg)
				break
			else: self.log.warning('Unhandled ws msg type {}, ignoring: {}', msg.type, msg)

	def ws_poller_done(self, fut):
		err = fut.exception()
		if err:
			self.log.exception( 'Unhandled ws handler'
				' failure, aborting: {}', err_fmt(err), exc_info=err )
		self.tasks.add(self.ws_close())

	def ws_send(self, op, d):
		msg_data = json.dumps(dict(op=op, d=d))
		if self.conf.discord_ws_debug: self.log.debug('ws  >> {}', msg_data)
		# XXX: maybe enforce ordering for messages here
		self.tasks.add(self.ws.send_str(msg_data))

	async def ws_close(self):
		if self.ws_closed.is_set(): return
		if self.conf.discord_ws_debug: self.log.debug('ws  >> -close-')
		if self.ws: await self.ws.close()
		self.ws_closed.set() # XXX: monitor for reconnect, close/wait ws_ctx there
		await self.ws_tasks.close()
		self.ws_ctx = self.ws = self.ws_tasks = self.ws_handlers = None


	### Gateway Websocket protocol
	# XXX: rate limits here?

	def op_track_seq(self, m): self.seq = m.s
	def op_hello(self, m):
		interval = m.d.heartbeat_interval / 1e3
		self.log.debug('Heartbeat interval: {:,.2f}', interval)
		self.ws_tasks.add(self.op_heartbeat_task(interval))
		# XXX: send c.identify msg + next steps

	async def op_heartbeat_task(self, interval):
		self.hb_ts_ack = hb_ts = self.loop.time() + interval
		self.ws_add_handler(self.c.heartbeat_ack, self.op_heartbeat_ack)
		while not self.ws_closed.is_set():
			self.ws_send(self.c.heartbeat, self.seq)
			ts = self.loop.time()
			if self.hb_ts_ack < ts - interval*2:
				self.log.error('Missing heartbeat ack, reconnecting')
				await self.ws_close() # XXX: some clean close command?
			delay = hb_ts - ts
			while hb_ts < ts: hb_ts += interval
			await asyncio.sleep(delay)

	async def op_heartbeat_ack(self, m):
		self.hb_ts_ack = self.loop.time()



class RDIRCD:

	def __init__(self, loop, conf):
		self.loop, self.conf = loop, conf
		self.log = get_logger('rdircd.bridge')

	async def __aenter__(self):
		self.server_ver = '1.0.0'
		self.server_ts = dt.datetime.utcnow()
		self.server_host = os.uname().nodename
		self.irc_conns, self.irc_conns_max = dict(), 0
		self.irc_auth_tbf = token_bucket(self.conf.irc_auth_tbf)
		self.nick_sys, self.chans_sys = 'core', dict(
			control='rdircd control channel, type "help" for more info',
			debug='rdircd debug logging channel, read-only' )
		self.tasks = StacklessContext()
		return self

	async def __aexit__(self, *err):
		if self.tasks: await self.tasks.close()

	async def run(self):
		ircd = await self.loop.create_server(
			IRCProtocol.factory_for_bridge(self),
			self.conf.irc_host, self.conf.irc_port,
			family=self.conf.irc_host_af, start_serving=False )
		self.log.debug('Initializing discord...')
		try:
			async with Discord(self) as discord:
				self.log.debug('Starting ircd...')
				ircd_task = self.tasks.add(ircd.serve_forever())
				if self.conf.discord_auto_connect:
					self.log.debug('Auto-connecting discord...')
					self.loop.call_soon(discord.connect)
				await ircd_task
		except DiscordAbort as err:
			self.log.error('Discord init failure - {}', err_fmt(err))
		self.log.debug('Finished')

	async def run_async(self):
		async with self: await self.run()


	def irc_conn_new(self, irc):
		self.irc_conns[id(irc)] = irc
		self.irc_conns_max = max(self.irc_conns_max, len(self.irc_conns))
	def irc_conn_lost(self, irc): self.irc_conns.pop(id(irc), None)
	def irc_conn_stats(self):
		stats = adict(
			servers=1, chans=0, # XXX: number of servers/chans from discord
			total=0, total_max=self.irc_conns_max, unknown=0, auth=0, op=0 )
		for conn in self.irc_conns.values():
			stats.total += 1
			if conn.st.auth: stats.auth += 1
			else: stats.unknown += 1
		return stats


	def cmd_delay(self, delay, func):
		if delay and not isinstance(delay, (int, float)):
			if delay == 'irc_auth': delay = next(self.irc_auth_tbf)
			else: raise ValueError(delay)
		if delay: self.tasks.add(asyncio.sleep(delay), func)
		else: func()

	def cmd_conn(self, name=None):
		for conn in self.irc_conns.values():
			if not name or name == conn.st.nick: return conn
	@iter_gather(list)
	def cmd_chan_conns(self, name):
		for conn in self.irc_conns.values():
			if name in conn.st.chans: yield conn
	# XXX: def cmd_chan_names_discord(self, name):
	@iter_gather(list)
	def cmd_chan_names(self, name):
		for conn in self.cmd_chan_conns(name): yield conn.st.nick
		# XXX: cmd_chan_names_discord()

	@iter_gather(adict)
	def cmd_chan_map(self):
		for name, topic in self.chans_sys.items():
			yield (name, adict( name=name, topic=topic,
				names=self.cmd_chan_names(name),
				ts_created=self.server_ts.timestamp() ))
		# XXX: list discord channels/users here as well

	def cmd_control_status(self, conn, chan):
		for line in [
				'Status:',
				'  XXX: show whether stuff is connected and working atm' ]:
			conn.cmd_msg_synth(self.nick_sys, chan, line)

	def cmd_control(self, conn, text, chan):
		line = text.strip().split()
		if not line: return
		cmd, send = line[0],\
			ft.partial(conn.cmd_msg_synth, self.nick_sys, chan)
		if cmd == 'help':
			self.cmd_control_status(conn, chan)
			for line in [
					'Commands:',
					'  status - (alias: st) show whether discord is connected and working',
					'  connect - (alias: on) connect/login to discord api',
					'  disconnect - (alias: off) disconnect from discord' ]:
				send(line)
		elif cmd in ['status', 'st']: self.cmd_control_status(conn, chan)
		elif cmd in ['connect', 'on']:
			send('discord: connecting...')
			self.discord.connect()
		elif cmd in ['disconnect', 'off']:
			send('discord: disconnecting...')
			self.discord.disconnect()

	def cmd_log(self, line):
		conn = self.cmd_conn()
		if not conn: return
		conn.cmd_msg_synth(self.nick_sys, '#debug', line)



class RDIRCDConfig:

	version = '1.0'

	irc_host = '127.0.0.1'
	irc_port = 6667
	irc_password = ''
	irc_host_af = 0
	irc_auth_tbf = '30:8'

	discord_auto_connect = False
	discord_client_id = ''
	discord_client_secret = ''
	discord_redirect_url = 'https://localhost'
	discord_api_url = 'https://discordapp.com/api/v{api_ver}/'
	discord_ws_timeout = 20.0
	discord_ws_heartbeat = 15.0
	discord_ws_debug = True
	discord_user_agent = ( f'rdircd/{version}'
		f' (reliable-discord-irc-client) aiohttp/{aiohttp.__version__}' )

	auth_main_code = ''
	auth_main_token = ''
	auth_main_token_refresh = ''
	auth_ghost_code = ''
	auth_ghost_token = ''
	auth_ghost_token_refresh = ''
	auth_gateway = ''

	# XXX: options for well-timestamped protocol logs

	_conf_path = '~/.rdircd.ini'
	_conf_sections = 'irc', 'discord', 'auth'

	def __repr__(self): return repr(vars(self))
	def get(self, *k): return getattr(self, '_'.join(k))
	def set(self, k, v): setattr(self, k, v)

	def pprint(self, title=None):
		cat, chk = None, re.compile(
			'^({})_(.*)$'.format('|'.join(map(re.escape, self._conf_sections))) )
		if title: print(f';; {title}')
		for k in sorted(dir(self)):
			m = chk.search(k)
			if not m: continue
			if m.group(1) != cat:
				cat = m.group(1)
				print(f'\n[{cat}]')
			v = self.get(k)
			if isinstance(v, bool): v = ['no', 'yes'][v]
			k = m.group(2).replace('_', '-')
			print(f'{k} = {v}')

	def update_from_file(self, config, section='default', prefix=None):
		for k in dir(self):
			if prefix:
				if not k.startswith(prefix): continue
				conf_k, k = k, k[len(prefix):]
			elif k.startswith('_'): continue
			else: conf_k = k
			v = getattr(self, conf_k)
			if isinstance(v, str): get_val = lambda *a: str(config.get(*a, raw=True))
			elif isinstance(v, bool): get_val = config.getboolean
			elif isinstance(v, int): get_val = lambda *a: int(re.sub(r'[ _]', '', config.get(*a)))
			elif isinstance(v, float): get_val = lambda *a: float(config.get(*a))
			else: continue # values with other types cannot be specified in config
			for k_conf in {k, k.replace('_', '-')}:
				try: self.set(conf_k, get_val(section, k_conf))
				except configparser.NoSectionError: pass
				except configparser.NoOptionError: pass

	def update_file_section(self, section, keys=None, path=None):
		if not path: path = self._conf_path
		if isinstance(path, str): path = pl.Path(path)
		sec_re, sec_k = re.compile(r'(?i)^\[\s*(\S+)\s*\]$'), str_norm(section)
		sec_prefix = section.lower().replace('-', '_') + '_'
		if not keys: keys = list(k for k in vars(self).keys() if k.startswith(sec_prefix))
		if isinstance(keys, str): keys = keys.split()
		for n, k in enumerate(keys):
			if not k.startswith(sec_prefix): k = sec_prefix + k
			k, v = k[len(sec_prefix):].replace('_', '-'), self.get(k)
			if isinstance(v, bool): v = ['no', 'yes'][v]
			keys[n] = k, v, re.compile(r'(?i)^' + k.replace('-', '[-_]') + r'\s*=')
		keys = dict((k, (v, rx)) for k, v, rx in keys)
		with path.open() as src, safe_replacement(path) as dst:
			lines, sec, sec_parse = list(), list(), False
			for n, line in enumerate(src):
				m, line = sec_re.search(line.strip()), line.rstrip()
				if m:
					k = str_norm(m.group(1))
					if k == sec_k:
						sec_parse = True
						if sec: line = '' # drop duplicate headers
					if k != sec_k: sec_parse = False
				if sec_parse: sec.append(line)
				else: lines.append(line)
			while sec and not sec[-1]: sec.pop()
			if not sec: sec.append(f'[{section}]')
			if lines and lines[-1]: lines.append('')
			for line in lines: dst.write(f'{line}\n')
			for n, line in enumerate(sec):
				for k, (v, rx) in keys.items():
					if not rx.search(line): continue
					if v is None: line = None
					else: line, keys[k] = f'{k} = {v}', (None, rx)
				if line is not None: dst.write(f'{line}\n')
			for k, (v, rx) in keys.items():
				if v is None: continue
				dst.write(f'{k} = {v}\n')



def main(args=None, conf=None):
	if not conf: conf = RDIRCDConfig()

	import argparse, textwrap
	dedent = lambda text: (textwrap.dedent(text).strip('\n') + '\n').replace('\t', '  ')
	text_fill = lambda s,w=100,ind='\t',ind_next=None,**k: textwrap.fill(
		s, w, initial_indent=ind, subsequent_indent=ind if ind_next is None else ind_next, **k )
	class SmartHelpFormatter(argparse.HelpFormatter):
		def __init__(self, *args, **kws):
			return super().__init__(*args, **kws, width=100)
		def _fill_text(self, text, width, indent):
			if '\n' not in text: return super()._fill_text(text, width, indent)
			return ''.join( indent + line
				for line in text.replace('\t', '  ').splitlines(keepends=True) )
		def _split_lines(self, text, width):
			return super()._split_lines(text, width)\
				if '\n' not in text else dedent(text).splitlines()

	parser = argparse.ArgumentParser(
		formatter_class=SmartHelpFormatter,
		description='Reliable personal discord-client to irc-server translation daemon.')

	group = parser.add_argument_group('Configuration file(s)')
	group.add_argument('-c', '--conf',
		metavar='file', action='append',
		help=f'''
			Path to configuration file to use.
			It will get updated with OAuth2 credentials
				(only adding or changing [auth] section), so has to be writable.
			Default: {conf._conf_path}''')
	group.add_argument('--conf-dump', action='store_true',
		help='Print all configuration settings, which will be used with'
			' currently detected (and/or specified) configuration file(s), and exit.')
	group.add_argument('--conf-dump-defaults', action='store_true',
		help='Print all default settings, which would be used'
			' if no configuration file(s) were overriding these, and exit.')

	group = parser.add_argument_group('Interfaces')
	group.add_argument('-i', '--irc-bind', metavar='host(:port)',
		help=f'''
			Address/host (to be resolved via gai) and port to bind IRC server to.
			When specifying port after raw IPv6 address,
				enclose the latter in [], for example - [::]:6667.
			Default: {conf.irc_host}:{conf.irc_port} or whatever is in --conf file.''')

	parser.add_argument('-d', '--debug', action='store_true', help='Verbose operation mode.')
	opts = parser.parse_args(sys.argv[1:] if args is None else args)

	if opts.conf_dump_defaults:
		conf.pprint('Default configuration options')
		return

	conf_file = configparser.ConfigParser(allow_no_value=True)
	conf_user_paths = list(map(
		os.path.expanduser, opts.conf or [conf._conf_path] ))
	for n, p in enumerate(conf_user_paths):
		mode = os.R_OK
		if n == len(conf_user_paths) - 1: mode |= os.W_OK
		if not os.access(p, mode):
			parser.error(f'Specified config file missing or inaccessible: {p}')
	conf_file.read(conf_user_paths)
	for k in conf._conf_sections:
		conf.update_from_file(conf_file, section=k, prefix=f'{k}_')
	conf._conf_path = conf_user_paths[-1]

	if opts.conf_dump:
		conf.pprint('Current configuration options')
		return

	log_fmt = '%(name)s %(levelname)5s :: %(message)s'
	if opts.debug: log_fmt = '%(asctime)s :: ' + log_fmt
	log_fmt = logging.Formatter(log_fmt)
	log_handler = logging.StreamHandler(sys.stderr)
	log_handler.setLevel(logging.DEBUG if opts.debug else logging.WARNING)
	log_handler.setFormatter(log_fmt)
	logging.root.addHandler(log_handler)
	logging.root.setLevel(0)
	log = get_logger('main')

	host, port, family = opts.irc_bind or conf.irc_host, conf.irc_port, conf.irc_host_af
	if host.count(':') > 1: host, port = str_part(host, ']:>', port)
	else: host, port = str_part(host, ':>', port)
	if '[' in host: family = socket.AF_INET6
	host, port = host.strip('[]'), int(port)
	try:
		addrinfo = socket.getaddrinfo( host, str(port),
			family=family, type=socket.SOCK_STREAM, proto=socket.IPPROTO_TCP )
		if not addrinfo: raise socket.gaierror('No addrinfo for host: {}'.format(host))
	except (socket.gaierror, socket.error) as err:
		parser.error( 'Failed to resolve irc socket parameters (address, family)'
			' via getaddrinfo: {!r} - [{}] {}'.format((host, port), err.__class__.__name__, err) )
	sock_af, sock_t, sock_p, _, sock_addr = addrinfo[0]
	log.debug(
		'Resolved irc host:port {!r}:{!r} to endpoint: {} (family: {}, type: {}, proto: {})',
		host, port, sock_addr, *(sockopt_resolve(pre, n)
			for pre, n in [('af_', sock_af), ('sock_', sock_t), ('ipproto_', sock_p)]) )
	assert ( sock_t == socket.SOCK_STREAM
		and sock_p == socket.IPPROTO_TCP ), [sock_t, sock_p]
	conf.irc_host_af, (conf.irc_host, conf.irc_port) = sock_af, sock_addr[:2]

	def handle_exception(err_t, err, err_tb):
		log.error('Unhandled error: {}', err_fmt(err), exc_info=(err_t, err, err_tb))
	sys.excepthook = handle_exception

	log.debug('Starting eventloop...')
	with contextlib.closing(asyncio.get_event_loop()) as loop:
		# if opts.debug: loop.set_debug(True)
		rdircd = RDIRCD(loop, conf)

		log_handler = LogFuncHandler(rdircd.cmd_log)
		log_handler.setLevel(logging.DEBUG if opts.debug else logging.INFO)
		log_handler.setFormatter(logging.Formatter('%(name)s %(levelname)5s :: %(message)s'))
		logging.root.addHandler(log_handler)

		rdircd_task = loop.create_task(rdircd.run_async())
		for sig in 'INT TERM'.split():
			loop.add_signal_handler(getattr(signal, f'SIG{sig}'), rdircd_task.cancel)
		with contextlib.suppress(asyncio.CancelledError):
			return loop.run_until_complete(rdircd_task)
	log.debug('Finished')

if __name__ == '__main__': sys.exit(main())
