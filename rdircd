#!/usr/bin/env python3

import itertools as it, operator as op, functools as ft
import os, sys, io, stat, logging, re, time, secrets, hashlib, enum, json, random
import contextlib, asyncio, socket, signal, inspect, unicodedata, urllib.parse
import configparser, tempfile, datetime as dt, pathlib as pl
import collections as cs, collections.abc as cs_abc

import aiohttp


err_fmt = lambda err: '[{}] {}'.format(err.__class__.__name__, err)

class LogMessage:
	def __init__(self, fmt, a, k): self.fmt, self.a, self.k = fmt, a, k
	def __str__(self): return self.fmt.format(*self.a, **self.k) if self.a or self.k else self.fmt

class LogStyleAdapter(logging.LoggerAdapter):
	def __init__(self, logger, extra=None):
		super(LogStyleAdapter, self).__init__(logger, extra or {})
	def log(self, level, msg, *args, **kws):
		if not self.isEnabledFor(level): return
		log_kws = {} if 'exc_info' not in kws else dict(exc_info=kws.pop('exc_info'))
		msg, kws = self.process(msg, kws)
		self.logger._log(level, LogMessage(msg, args, kws), (), **log_kws)

class LogFuncHandler(logging.Handler):
	def __init__(self, func):
		super().__init__()
		self.func, self.locked = func, False
	def emit(self, record):
		if self.locked: return # to avoid logging-of-logging loops, assuming sync call
		self.locked = True
		try: self.func(self.format(record))
		except Exception: self.handleError(record)
		finally: self.locked = False

get_logger = lambda name: LogStyleAdapter(logging.getLogger(name))

def str_part(s, sep, default=None):
	'Examples: str_part("user@host", "<@", "root"), str_part("host:port", ":>")'
	c = sep.strip('<>')
	if sep.strip(c) == '<': return (default, s) if c not in s else s.split(c, 1)
	else: return (s, default) if c not in s else s.rsplit(c, 1)

def sockopt_resolve(prefix, v):
	prefix = prefix.upper()
	for k in dir(socket):
		if not k.startswith(prefix): continue
		if getattr(socket, k) == v: return k[len(prefix):]
	return v

class adict(dict):
	def __init__(self, *args, **kws):
		super().__init__(*args, **kws)
		self.__dict__ = self
		self._make(self)
	def _make(self, v):
		if v is self: v.update((k, self._make(v)) for k,v in v.items())
		elif type(v) is dict: v = adict(v)
		elif isinstance(v, (tuple, list)): v = type(v)(map(self._make, v))
		return v

def force_list(v):
	if not v: return list()
	if not isinstance(v, list): return [v]
	return v

def dict_sync(d, *du_args, **du_kws):
	keys_old, du = set(d.keys()), dict()
	if ( len(du_args) == 1 and
		isinstance(du_args[0], cs_abc.Generator) ): du_ags = list(du_args[0])
	if du_args: du.update(*du_args)
	if du_kws: du.update(**du_kws)
	d.update(du)
	return dict((k, d.pop(k)) for k in keys_old.difference(du))

def iter_gather(cls):
	def _cls_wrapper(func):
		@ft.wraps(func)
		def _wrapper(*args, **kws): return cls(func(*args, **kws))
		return _wrapper
	return _cls_wrapper

str_norm = lambda v: unicodedata.normalize('NFKC', v.strip()).casefold()

@contextlib.contextmanager
def safe_replacement(path, *open_args, mode=None, **open_kws):
	path = str(path)
	if mode is None:
		try: mode = stat.S_IMODE(os.lstat(path).st_mode)
		except OSError: pass
	open_kws.update( delete=False,
		dir=os.path.dirname(path), prefix=os.path.basename(path)+'.' )
	if not open_args: open_kws['mode'] = 'w'
	with tempfile.NamedTemporaryFile(*open_args, **open_kws) as tmp:
		try:
			if mode is not None: os.fchmod(tmp.fileno(), mode)
			yield tmp
			if not tmp.closed: tmp.flush()
			os.rename(tmp.name, path)
		finally:
			try: os.unlink(tmp.name)
			except OSError: pass

def token_bucket(spec, negative_tokens=False):
	'''Spec: { interval_seconds: float | float_a/float_b }[:burst_float]
			Examples: 1/4:5 (interval=0.25s, rate=4/s, burst=5), 5, 0.5:10, 20:30.
		Expects a number of tokens (can be float, default: 1)
			and *always* subtracts these.
		Yields either None if there's enough
			tokens or delay (in seconds, float) until when there will be.'''
	try:
		try: interval, burst = spec.rsplit(':', 1)
		except (ValueError, AttributeError): interval, burst = spec, 1.0
		else: burst = float(burst)
		if isinstance(interval, str):
			try: a, b = interval.split('/', 1)
			except ValueError: interval = float(interval)
			else: interval = float(a) / float(b)
		if min(interval, burst) < 0: raise ValueError()
	except: raise ValueError('Invalid format for rate-limit: {!r}'.format(spec))
	# log.debug('tbf parameters: interval={:.1f}, burst={:.1f}', interval, burst)
	tokens, rate, ts_sync = burst, interval**-1, time.monotonic()
	val = (yield) or 1
	while True:
		ts = time.monotonic()
		ts_sync, tokens = ts, min(burst, tokens + (ts - ts_sync) * rate)
		val, tokens = (None, tokens - val) if tokens >= val else\
			((val - tokens) / rate, (tokens - val) if negative_tokens else tokens)
		val = (yield val) or 1

async def await_wrap(res):
	if inspect.isawaitable(res): res = await res
	return res

async def task_cancel_list(task_list):
	task_list = list(task for task in task_list if task and not task.done())
	for task in task_list:
		with contextlib.suppress(asyncio.CancelledError): task.cancel()
	for task in task_list:
		with contextlib.suppress(asyncio.CancelledError): await task

class StacklessContext:
	'''Like AsyncContextStack, but for tracking tasks that
		can finish at any point without leaving stack frames.'''

	def __init__(self): self.tasks = dict()
	async def __aenter__(self): return self
	async def __aexit__(self, *err):
		if self.tasks:
			task_list, self.tasks = self.tasks.values(), None
			await task_cancel_list(task_list)
	async def close(self): await self.__aexit__(None, None, None)

	def add_task(self, coro, run_after=None):
		'Start task eating its own tail, with an optional success-only callback'
		task_id = None
		async def _task_wrapper(coro=coro):
			try:
				await coro
				if run_after:
					coro = run_after()
					if asyncio.iscoroutine(coro): await coro
			# except TypeError:
			# 	print('----- coro', coro, file=sys.stderr)
			# 	raise
			finally:
				assert task_id is not None, task_id
				if self.tasks: self.tasks.pop(task_id, None)
		task = asyncio.create_task(_task_wrapper())
		task_id = id(task)
		self.tasks[task_id] = task
		return task
	add = add_task



class IRCProtocolError(Exception): pass
class IRCProtocolArgsError(IRCProtocolError): pass

class IRCProtocol:

	# Extensive lists of modes are copied from freenode to make clients happy
	feats_modes = 'DOQRSZaghilopswz CFILMPQSbcefgijklmnopqrstvz'
	feats_support = ( 'AWAYLEN=200 CASEMAPPING=ascii'
		' CHANLIMIT=#:512 CHANTYPES=# CHANMODES=eIbq,k,flj,CFLMPQScgimnprstz'
		' CHANNELLEN=80 ELIST=C NETWORK=rdircd NICKLEN=64'
		' PREFIX=(ov)@+ SAFELIST STATUSMSG=@+ TOPICLEN=390 USERLEN=32' ).split()

	@classmethod
	def factory_for_bridge(cls, rdircd):
		def _wrapper():
			try: return cls(rdircd)
			except Exception as err:
				log = get_logger('rdircd.irc')
				log.exception('Failed to initialize ircd protocol: {}', err_fmt(err))
				log.critical('Stopping daemon due to unhandled protocol error')
				loop.stop()
		return _wrapper

	def __init__(self, rdircd):
		self.bridge, self.loop, self.conf = rdircd, rdircd.loop, rdircd.conf
		self.log = get_logger('rdircd.irc')
		self.transport, self.buff = None, b''
		self.st = adict(
			nick=None, user=None, pw=None, pw_hash=None,
			host=None, auth=False, cap_neg=False, chans=set() )
		if self.conf.irc_password:
			salt = os.urandom(8)
			self.st.pw_hash = salt, hashlib.blake2b(
				self.conf.irc_password.encode(), salt=salt ).digest()


	def connection_made(self, tr):
		host, port = tr.get_extra_info('peername')[:2]
		self.log.debug('Connection from {}', host)
		self.transport, self.st.host = tr, host
		self.send('NOTICE * :*** rdircd ready')
		self.bridge.irc_conn_new(self)

	def data_received(self, data):
		self.buff += data
		while b'\n' in self.buff:
			line, self.buff = self.buff.split(b'\n', 1)
			line_len, line_repr = self._repr(line, True)
			self.log.debug('<<  [{} {}] {}', self.st.nick or '---', line_len, line_repr)
			if not line.strip(): continue
			self.recv(line)

	def eof_received(self): pass
	def connection_lost(self, err):
		self.log.debug('Connection lost: {}', err or 'closed cleanly')
		self.bridge.irc_conn_lost(self)

	def data_send(self, data):
		data_len, data_repr = self._repr(data, True)
		self.log.debug(' >> [{} {}] {}', self.st.nick or '---', data_len, data_repr)
		self.transport.write(data)


	def _repr(self, data, prefix=False, max_len=None, ext=' [{data_len}]'):
		if isinstance(data, str): data = data.encode()
		if max_len is None: max_len = self.conf.debug_str_cut
		data_len, data_repr, ext_len = f'{len(data):03,d}', repr(data)[2:-1], len(ext)
		if max_len > 0 and len(data_repr) > max_len:
			data_len = f'{max_len}/{data_len}'
			data_repr = data_repr[:max_len - ext_len] + ext.format(data_len=data_len)
		return (data_len, data_repr) if prefix else data_repr

	def _parse(self, line):
		if isinstance(line, bytes): line = line.decode()
		m = adict(line=line, params=list())
		for k in '@tags', ':src':
			pre, k = k[0], k[1:]
			if line.startswith(pre):
				try: m[k], line = line.split(' ', 1)
				except ValueError:
					raise IRCProtocolLineError(line) from None
				line = line.lstrip(' ')
			else: m[k] = None
		while True:
			if line.startswith(':'):
				m.params.append(line[1:])
				break
			if ' ' in line:
				param, line = line.split(' ', 1)
				line = line.lstrip(' ')
			else: param, line = line, ''
			m.params.append(param)
			if not line: break
		if m.params: m.cmd, m.params = m.params[0].lower(), m.params[1:]
		else: raise IRCProtocolLineError(line)
		return m

	def send(self, line_or_code, *args, max_len=450, auto_split=True):
		line = line_or_code
		if isinstance(line, int): line = f'{line:03d} {self.st.nick or "*"}'
		if args: line += ' ' + ' '.join(map(str, args))
		if isinstance(line, str): line = line.encode()
		line = line.rstrip(b'\r\n')
		if b'\n' in line or len(line) > max_len:
			if auto_split:
				m = self._parse(line)
				if m.cmd == 'privmsg': return self.send_split_privmsg(m)
			if len(line) > max_len:
				self.log.warning('Sending line with >{}B: {!r}', max_len, self._repr(line))
		line += b'\r\n'
		self.data_send(line)

	def send_split_privmsg(self, m, max_len=300):
		dst, line = m.params
		pre = f'{m.cmd.upper()} {dst}'
		if m.src: pre = f'{m.src} {pre}'
		if '\n' in line:
			for line in line.split('\n'): self.send(pre, f':{line.rstrip()}')
			return
		line, ws = '', re.findall(r'(\S+)(\s*)', line)
		for w, sep in ws:
			if line.strip() and len(line) + len(w) > max_len:
				self.send(pre, f':{line.rstrip()}', auto_split=False)
				line = sep_last
			sep_last, line = sep, line + w + sep
		if line.strip(): self.send(pre, f':{line.rstrip()}', auto_split=False)

	def recv(self, line_raw, _cmd_cache=dict()):
		if isinstance(line_raw, str): line = line_raw
		else:
			try: line = line_raw.decode().strip()
			except UnicodeDecodeError:
				return self.log.error('Failed to decode line as utf-8: {!r}', self._repr(line_raw))
		try: m = self._parse(line)
		except IRCProtocolLineError:
			return self.log.error('Line protocol error: {!r}', self._repr(line_raw))
		cmd_cache = _cmd_cache.get(m.cmd)
		if cmd_cache: cmd_func, cmd_ps_n = cmd_cache
		else:
			cmd_func, cmd_ps_n = getattr(self, f'recv_cmd_{m.cmd}', None), 0
			if cmd_func:
				args = list(inspect.signature(cmd_func).parameters.values())
				cmd_ps_n = len(args)
				if cmd_ps_n == 1 and args[0].annotation == 'msg': cmd_ps_n = None
				else: cmd_ps_n = cmd_ps_n - sum(1 for p in args if p.default is not p.empty), cmd_ps_n
			_cmd_cache[m.cmd] = cmd_func, cmd_ps_n
		if not cmd_func:
			self.log.error('Unhandled cmd: {!r}', self._repr(line_raw))
			return self.send(421, ':Unknown command')
		if not self.check_access(m.cmd):
			return self.log.error('Out-of-order cmd: {!r}', self._repr(line_raw))
		if cmd_ps_n is None: cmd_func(m)
		else:
			(a, b), n = cmd_ps_n, len(m.params)
			if not a <= n <= b:
				self.log.error( 'Command/args'
					' mismatch [{} vs {}-{}]: {!r}', n, a, b, self._repr(line) )
				return self.send(461, ':Incorrect command parameters')
			try: cmd_func(*m.params)
			except Exception as err:
				self.send(400, m.cmd.upper(), f':BUG - Internal Error - {err_fmt(err)}')
				self.log.exception('Error processing message: {}', m)

	def check_access(self, cmd):
		if self.st.cap_neg: return cmd in ['cap', 'quit']
		if not self.st.auth:
			res = cmd in ['cap', 'user', 'nick', 'pass', 'quit', 'ping']
			if not res: self.send(451, ':You have not registered')
			return res
		res = cmd not in ['user', 'pass']
		if not res: self.send(462, ':You may not reregister')
		return res

	def recv_cmd_ping(self, server, server_dst=None):
		self.send(f'PONG {self.bridge.server_host}')

	def recv_cmd_cap(self, sub, caps=''):
		sub = sub.lower()
		if sub == 'ls':
			self.send('CAP * LS :')
			if caps == '302': self.st.cap_neg = True
		elif sub == 'list': self.send('CAP * LIST :')
		elif sub == 'req':
			self.st.cap_neg = True
			reject = set(c for c in caps.split() if not c.startswith('-'))
			if reject: self.send(f'CAP * NAK :{caps}')
			else: self.send(f'CAP * ACK :{caps}')
		elif sub == 'end': self.st.cap_neg = False

	def recv_cmd_pass(self, pw):
		self.st.pw = pw
		self.check_auth_done()
	def recv_cmd_user(self, name, a, b, real_name):
		self.st.update(user=name, real_name=real_name)
		self.check_auth_done()
	def recv_cmd_nick(self, nick):
		if not re.search(r'^[a-zA-Z-._]+$', nick):
			return self.send(432, nick, ':Erroneus nickname')
		if self.bridge.cmd_conn(nick):
			return self.send(433, nick, ':Nickname is already in use')
		self.st.nick = nick
		if self.st.auth and self.st.nick:
			self.send(f':{self.st.nick} NICK {nick}')
		self.check_auth_done()

	def check_auth_done(self):
		# Delay is to avoid trivial bruteforcing
		self.bridge.cmd_delay('irc_auth', self.check_auth_done_delayed)

	def check_auth_done_delayed(self):
		if self.st.auth: return
		if not (self.st.nick and self.st.user): return
		if self.st.pw_hash:
			salt, pw_hash = self.st.pw_hash
			if not secrets.compare_digest( pw_hash,
					hashlib.blake2b((self.st.pw or '').encode(), salt=salt).digest() ):
				return self.send(464, ':Password incorrect')
		self.st.auth = True
		self.send('NOTICE * :*** registration completed')
		self.send(1, f':Welcome to the rdircd discord-irc bridge, {self.st.nick}')
		self.send(2,
			f':Your host is {self.bridge.server_host},'
			f' running rdircd {self.bridge.server_ver}' )
		self.send(3, ':This server was created at {}'.format(
			self.bridge.server_ts.strftime('%Y-%m-%d %H:%M:%S UTC') ))
		self.send(4, f'{self.bridge.server_host} rdircd-{self.bridge.server_ver} {self.feats_modes}')
		self.send_feats()
		self.send_stats()
		self.send_motd()

	def send_feats(self, msg_feats_max=10, msg_len_max=200):
		feat_line, ext = list(), ':are supported by this server'
		for feat in it.chain(self.feats_support, [None]):
			if feat: feat_line.append(feat)
			n, msg_len = len(feat_line), sum((len(f)+1) for f in feat_line)
			if feat_line and (not feat or n >= msg_feats_max or msg_len >= msg_len_max):
				self.send(5, ' '.join(feat_line), ext)
				feat_line.clear()

	def send_stats(self):
		s = self.bridge.irc_conn_stats()
		self.send(251, f':There are {s.auth} users and 0 invisible on {s.servers} server(s)')
		self.send(252, f'{s.op} :IRC Operators online')
		self.send(253, f'{s.unknown} :unknown connection(s)')
		self.send(254, f'{s.chans} :channels formed')
		self.send(255, f':I have {s.total} client(s) and {s.servers} server(s)')
		self.send( 265, f'{s.total} {s.total_max}',
			f':Current local users {s.total}, max {s.total_max}' )
		self.send( 266, f'{s.total} {s.total_max}',
			f':Current global users {s.total}, max {s.total_max}' )

	def send_motd(self): self.send(422, ':MOTD File is missing')

	def recv_cmd_quit(self, reason=None):
		self.send('QUIT :Client quit')
		self.send('ERROR :Closing connection (client quit)')
		self.transport.close()

	def req_chan_info(self, chan, cm=None):
		if not chan.startswith('#'):
			self.send(403, chan, ':No such channel')
			return
		if not cm: cm = self.bridge.cmd_chan_map()
		c = cm.get(chan[1:])
		if not c: self.send(403, chan, ':No such channel')
		return c

	def recv_cmd_join(self, chan, key=None):
		if chan == '0': return self.recv_cmd_part(','.join(self.st.chans))
		chan_list, chan_map = chan.split(','), self.bridge.cmd_chan_map()
		for chan in chan_list:
			c = self.req_chan_info(chan, cm=chan_map)
			if not c: continue
			self.send(f':{self.st.nick} JOIN {chan}')
			self.send_topic(chan, c=c)
			self.send_names(chan, own=True, c=c)
			self.st.chans.add(c.name)

	def recv_cmd_part(self, chan, reason=None):
		chan_list, chan_map = chan.split(','), self.bridge.cmd_chan_map()
		for chan in chan_list:
			c = self.req_chan_info(chan, cm=chan_map)
			if not c: continue
			if c.name not in self.st.chans:
				self.send(442, chan, ':You are not on that channel')
			else:
				self.st.chans.remove(c.name)
				self.send(f'PART {chan}')

	def recv_cmd_topic(self, chan, topic=None):
		if not topic: self.send_topic(chan)
		else: self.send(482, chan, ':You are not channel operator')

	def send_topic(self, chan, c=None):
		if not c: c = self.req_chan_info(chan)
		if not c: return
		if not c.topic: self.send(331, chan, ':No topic is set')
		else:
			self.send(332, chan, f':{c.topic}')
			topic_src = c.get('topic_src')
			if topic_src: self.send(333, chan, topic_src.nick, int(topic_src.ts))

	def recv_cmd_names(self, chan):
		chan_list = chan.split(',')
		for chan in chan_list: self.send_names(chan)

	def send_names(self, chan, own=False, c=None, msg_len_max=200):
		if not c: c = self.req_chan_info(chan)
		if not c: return
		name_line = list()
		for name in it.chain(c.names, [None]):
			if name:
				if name == self.st.nick: own = False
				name_line.append(name)
			elif own: name_line.append(self.st.nick)
			if name_line and (
					not name or sum(len(n)+1 for n in name_line) > msg_len_max ):
				self.send(353, '=', chan, ':' + ' '.join(name_line))
				name_line.clear()
		self.send(366, chan, ':End of /NAMES list')

	def recv_cmd_mode(self, target, mode=None, mode_args=None):
		if target.startswith('#'):
			chan = target
			c = self.req_chan_info(chan)
			if not c: return
			self.send(324, chan, '+cnrt')
			self.send(329, chan, int(c.ts_created))
		else:
			if target != self.st.nick:
				self.send(502, ':No access to modes of other users')
				return
			self.send(221, ':+w')

	def recv_cmd_list(self, chan=None, cond=None):
		# XXX: searching for new channels (ELIST=C) might be nice to have
		self.send(321, 'Channel :Users  Name')
		for c in self.bridge.cmd_chan_map().values():
			self.send(322, f'#{c.name}', len(c.names), f':{c.topic}')
		self.send(321, ':End of /LIST')

	def recv_cmd_motd(self, target=None): self.send_motd()

	def recv_cmd_version(self, target=None):
		self.send(351, self.bridge.server_ver, 'rdircd', ':rdircd discord-to-irc bridge')
		self.send_feats()

	def recv_cmd_userhost(self, nick):
		if str_norm(nick) == str_norm(self.st.nick):
			self.send(302, f':{nick}=+~{self.st.user}@{self.st.host}')
		else: self.send(401, nick, ':No such nick/channel') # XXX: info for discord nicks

	# def recv_cmd_whois(self, nick): # XXX: RPL_*WHOIS* + discord info via notices?

	def recv_cmd_privmsg(self, target, text):
		self.cmd_msg(self.st.nick, target, text, skip_self=True)

	def recv_cmd_notice(self, target, text):
		self.cmd_msg(self.st.nick, target, text, notice=True, skip_self=True)

	def cmd_msg(self, src, target, text, notice=False, skip_self=False, msg_type=None):
		# XXX: auto-split long text here
		if not msg_type: msg_type = 'PRIVMSG' if not notice else 'NOTICE'
		if target.startswith('#'):
			chan = target
			if not notice: c = self.req_chan_info(chan)
			else: c = self.bridge.cmd_chan_map().get(chan[1:])
			if not c: return
			for conn in self.bridge.cmd_chan_conns(c.name):
				if skip_self and conn is self: continue
				conn.send(f':{src} {msg_type} {chan} :{text}')
			if not notice and c.name == 'control':
				self.bridge.cmd_control(self, text, chan)
		else:
			conn = self.bridge.cmd_conn(target)
			if not conn:
				if not notice: self.send(401, target, ':No such nick/channel')
			else: conn.send(f':{src} {msg_type} {target} :{text}')

	def cmd_msg_synth(self, src, target, text):
		'Synthetic PRIVMSG which avoids any self-reaction loops like notices'
		return self.cmd_msg(src, target, text, notice=True, msg_type='PRIVMSG')

	# XXX: more server info commands
	# def recv_cmd_admin(self):
	# def recv_cmd_connect(self):
	# def recv_cmd_time(self):
	# def recv_cmd_stats(self):
	# def recv_cmd_info(self):



class DiscordError(Exception): pass
class DiscordAbort(DiscordError): pass
class DiscordHTTPError(DiscordError): pass
class DiscordSessionError(Exception): pass


class Discord:

	def __init__(self, rdircd):
		self.bridge, self.loop, self.conf = rdircd, rdircd.loop, rdircd.conf
		self.log = get_logger('rdircd.discord.main')

	async def __aenter__(self):
		self.sessions = adict()
		for acc in 'main', 'ghost':
			if not ( self.conf.get(f'auth_{acc}_email')
					and self.conf.get(f'auth_{acc}_password') ):
				self.log.info('Disabling account with no access credentials: {}', acc)
				continue
			self.sessions[acc] = s = DiscordSession(self, acc)
			s.task = self.loop.create_task(s.run_async())
		return self

	async def __aexit__(self, *err):
		await task_cancel_list(s.task for s in self.sessions.values())

	def connect(self):
		for s in self.sessions.values(): s.connect()
	def disconnect(self):
		for s in self.sessions.values(): s.disconnect()


class DiscordSession:

	api_ver = 6

	class c(enum.IntEnum):
		dispatch = 0
		heartbeat = 1
		identify = 2
		status_update = 3
		voice_state_update = 4
		resume = 6
		reconnect = 7
		request_guild_members = 8
		invalid_session = 9
		hello = 10
		heartbeat_ack = 11
		unknown_error = 4000
		unknown_opcode = 4001
		decode_error = 4002
		not_authenticated = 4003
		authentication_failed = 4004
		already_authenticated = 4005
		invalid_seq = 4007
		rate_limited = 4008
		session_timeout = 4009
		invalid_shard = 4010
		sharding_required = 4011

	class c_chan_type(enum.IntEnum):
		text = 1
		private = 2
		voice = 3
		private_group = 4

	def __init__(self, discord, t):
		self.discord, self.loop, self.conf, self.t = discord, discord.loop, discord.conf, t
		self.api_url = self.conf.discord_api_url.format(api_ver=self.api_ver)
		self.log = get_logger(f'rdircd.discord.{self.t}')

	def get_auth(self, k, default=ValueError):
		try: return getattr(self.conf, f'auth_{self.t}_{k}')
		except AttributeError as err:
			if default is ValueError: raise
			return default

	async def __aenter__(self):
		if not (self.get_auth('email') and self.get_auth('password')):
			raise DiscordSessionError('Missing account auth credentials')
		self.ctx, self.tasks = contextlib.AsyncExitStack(), StacklessContext()
		self.http = await self.ctx.enter_async_context(aiohttp.ClientSession())
		self.ws_ctx = self.ws = self.ws_tasks = self.ws_handlers = None
		self.rate_limits, self.ws_closed, self.st = adict(), asyncio.Event(), adict()
		self.auth_token = self.get_auth('token')
		return self

	async def __aexit__(self, *err):
		if self.ws_ctx:
			await self.ws_ctx.aclose()
			self.ws_ctx = None
		if self.ctx:
			await self.ctx.aclose()
			self.ctx = None
		if self.tasks: await self.tasks.close()

	async def run(self):
		self.log.debug('Starting discord session...')
		try: await asyncio.Future()
		except asyncio.CancelledError: pass
		self.log.debug('Finished')

	async def run_async(self):
		async with self: await self.run()

	def connect(self):
		# XXX: start reconnect logic/task, report back to irc control
		return self.tasks.add(self.ws_connect())
	def disconnect(self): return self.tasks.add(self.ws_close())

	def state(self, st):
		st_old, self.st.state = self.st.get('state', 'none'), st
		if st == st_old: return
		self.log.info('State: {} -> {}', st_old, st)

	def _repr(self, s, prefix=False, max_len=None, ext=' ...[{s_len}]'):
		if isinstance(s, bytes): s = s.decode('utf-8', 'replace')
		if not isinstance(s, str): s = str(s)
		if max_len is None: max_len = self.conf.debug_str_cut
		s_len, s_repr, ext_len = f'{len(s):03,d}', repr(s)[1:-1], len(ext.format(s_len=9999))
		if max_len > 0 and len(data_repr) > max_len:
			s_len = f'{max_len}/{s_len}'
			s_repr = s_repr[:max_len - ext_len] + ext.format(s_len=s_len)
		return (s_len, s_repr) if prefix else s_repr


	### Regular HTTP requests and OAuth2 stuff

	async def rate_limit_wrapper(self, route, req_func):
		# XXX: global limits currently only handled via http-429
		req_limit_defaults = 1, None
		while True:
			ts = time.time()
			req_limit, req_limit_ts = self.rate_limits.get(route) or req_limit_defaults
			if req_limit_ts and ts > req_limit_ts: req_limit = 1
			if req_limit <= 0 and req_limit_ts and req_limit_ts > ts:
				delay = req_limit_ts - ts
				self.log.debug('Rate-limiting request on route {!r}: delay={:,.1f}s', route, delay)
				await asyncio.sleep(delay + self.conf.discord_http_delay_padding)
			res = await req_func()
			req_limit_headers = list( res.headers.get(k)
				for k in ['X-RateLimit-Remaining', 'X-RateLimit-Reset'] )
			if any(req_limit_headers):
				warn, req_limit_vals = False, list(req_limit_defaults)
				for n, v in enumerate(req_limit_headers):
					try: req_limit_vals[n] = float(v)
					except ValueError as err: warn = False
				if warn:
					self.log.warning( 'Failed to parse rate-limit http'
						' header value(s), assuming default(s): {!r} / {!r}', *req_limit_headers )
				req_limit, req_limit_ts = self.rate_limits[route] = req_limit_vals
			if res.status == 429:
				m = await res.json()
				delay = m.get('retry_after')
				if delay:
					self.log.debug( 'Rate-limiting request on route'
							' {!r}: explicit-retry-after, delay={:,.1f}s, global={}, msg={!r}',
						route, delay, m.get('global'), m.get('message') )
					await asyncio.sleep(float(delay) / 1e3 + self.conf.discord_http_delay_padding)
					continue
				elif req_limit <= 0 and req_limit_ts and req_limit_ts > time.time(): continue
				else:
					raise DiscordSessionError(
						'Failed to get API rate-limiting retry delay for http-429 error' )
			break
		return res

	async def req_auth_token(self):
		if isinstance(self.auth_token, asyncio.Event): await self.auth_token
		elif not self.auth_token:
			self.auth_token = asyncio.Event()
			email, pw = (self.get_auth(k) for k in ['email', 'password'])
			res = await self.req( 'auth/login', m='post',
				auth=False, json=dict(email=email, password=pw) )
			if res.get('mfa'):
				raise DiscordSessionError( 'Multi-factor auth'
					' requirement detected, but is not supported by rdircd' )
			setattr(self.conf, f'auth_{self.t}_token', res['token'])
			self.conf.update_file_section(f'auth_{self.t}', 'token')
			self.auth_token.set()
			self.auth_token = self.get_auth('token')
		return self.auth_token

	async def req( self, url, m='get',
			route=None, auth=True, raw=False, **kws ):
		if not re.search(r'^https?:', url):
			url = urllib.parse.urljoin(self.api_url, url)
		if route is None: route = url
		kws.setdefault('headers', dict()).setdefault(
			'User-Agent', self.conf.discord_user_agent )
		for att in 'normal', 'token_refresh':
			if auth:
				token = await self.req_auth_token()
				kws.setdefault('headers', dict()).update(Authorization=token)
			req_func = ft.partial(self.http.request, m, url, **kws)
			self.log.debug('req  >> {} {}', m, url)
			res = await self.rate_limit_wrapper(route, req_func)
			if not auth: break
			if res.status == 401:
				res.release()
				if att != 'normal': raise DiscordSessionError('Auth failed')
		if res.status >= 400:
			body = await res.text()
			raise DiscordHTTPError(f'[{res.status}] {res.reason} - {body}')
		if not raw:
			res_raw, res = res, await res.json()
			res_raw.release()
		self.log.debug('req <<  {}', res)
		return res


	### Gateway Websocket wrappers

	async def ws_connect(self):
		if self.ws_ctx: return
		self.state('connecting.init')
		self.ws_ctx = ctx = contextlib.AsyncExitStack()
		self.ws_tasks, self.ws_handlers = StacklessContext(), dict()
		ctx.push_async_callback(self.ws_close)
		self.ws_closed.clear()
		for cache in True, False:
			if cache:
				if not self.conf.discord_gateway: continue
				self.state('connecting.ws.cached')
			else:
				self.state('connecting.ws.get-url')
				self.conf.discord_gateway = (await self.req('gateway', auth=False))['url']
				self.conf.update_file_section('discord', 'gateway')
			parts = adict(urllib.parse.urlsplit(self.conf.discord_gateway)._asdict())
			query = urllib.parse.parse_qs(parts.query)
			query.update(v=str(self.api_ver), encoding='json')
			parts.query = urllib.parse.urlencode(query)
			ws_url = urllib.parse.urlunsplit(tuple(parts.values()))
			self.state('connecting.ws')
			try:
				self.ws = await ctx.enter_async_context(self.http.ws_connect( ws_url,
					headers={'User-Agent': self.conf.discord_user_agent},
					heartbeat=self.conf.discord_ws_heartbeat, timeout=self.conf.discord_ws_timeout ))
			except aiohttp.ClientError as err:
				self.state('connecting.ws.error')
				self.log.error('Gateway connection error: {}', err_fmt(err))
				if cache: continue # try fetching new gw url
			else: break
		else: self.ws = None
		if not self.ws: # XXX: more specific error/details, handle wrt reconnect
			self.state('connecting.ws.fail')
			self.ws_closed.set()
			raise DiscordSessionError('Failed to connect to discord')
		self.state('connected')
		self.ws_add_handler(self.c.dispatch, self.op_track_seq)
		self.ws_add_handler(self.c.reconnect, self.op_reconnect)
		self.ws_add_handler(self.c.hello, self.op_hello)
		self.ws_add_handler(self.c.invalid_session, self.op_invalid_session_retry)
		self.ws_tasks.add(self.ws_poller()).add_done_callback(self.ws_poller_done)

	_ws_handler = cs.namedtuple('ws_handler', 'op t func')
	def ws_add_handler(self, op=None, func=None, t=None, replace=False, remove=False):
		if replace or remove:
			for k, wsh in list(self.ws_handlers.items()):
				if wsh.op == op and wsh.t == t: del self.ws_handlers[k]
			if remove: return
		if not func: raise ValueError(func)
		wsh = self._ws_handler(op, t, func)
		self.ws_handlers[wsh] = wsh

	async def ws_poller(self):
		# {op=0**, s=**42, d={...}, t=**'GATEWAY_EVENT_NAME'}
		# {op=...[, d={...}]}
		async for msg in self.ws:
			if self.conf.discord_ws_debug:
				self.log.debug( 'ws <<  {} {}',
					aiohttp.WSMsgType(msg.type).name.lower(),
					self._repr(getattr(msg, 'data', '')) )
			if msg.type == aiohttp.WSMsgType.text:
				msg_data, hs_discard, handled = adict(json.loads(msg.data)), set(), False
				for k, h in list(self.ws_handlers.items()):
					if h.op is not None and msg_data.get('op') != h.op: continue
					if h.t is not None and (msg_data.get('t') or '').lower() != h.t: continue
					handled = True
					oneshot = await await_wrap(h.func(msg_data))
					if oneshot: hs_discard.add(k)
				for k in hs_discard: self.ws_handlers.pop(k, None)
				if not handled: self.log.debug('Unhandled ws event: {}', self._repr(msg_data))
			elif msg.type == aiohttp.WSMsgType.closed: break
			elif msg.type == aiohttp.WSMsgType.error:
				self.log.error('ws protocol error, aborting: {}', msg)
				break
			else: self.log.warning('Unhandled ws msg type {}, ignoring: {}', msg.type, msg)

	def ws_poller_done(self, fut):
		err = fut.exception()
		if err:
			self.log.exception( 'Unhandled ws handler'
				' failure, aborting: {}', err_fmt(err), exc_info=err )
		self.tasks.add(self.ws_close())

	def ws_send(self, op, d):
		msg_data = json.dumps(dict(op=op, d=d))
		if self.conf.discord_ws_debug: self.log.debug('ws  >> {}', self._repr(msg_data))
		# XXX: maybe enforce ordering for messages here
		self.tasks.add(self.ws.send_str(msg_data))

	async def ws_close(self):
		if self.ws_closed.is_set(): return
		self.state('disconnected')
		if self.conf.discord_ws_debug: self.log.debug('ws  >> -close-')
		if self.ws: await self.ws.close()
		self.ws_closed.set() # XXX: monitor for reconnect, close/wait ws_ctx there
		await self.ws_tasks.close()
		self.ws_ctx = self.ws = self.ws_tasks = self.ws_handlers = None


	### Gateway Websocket protocol
	# XXX: rate limits here?

	def op_log_warn(self, m):
		self.log.warning('Unhandled event: {}', m)

	def op_track_seq(self, m): self.st.seq = m.s
	def op_reconnect(self, m):
		self.log.info('Received reconnect event - closing connection')
		self.tasks.add(self.ws_close)

	async def op_hello(self, m):
		self.state('hello')
		interval = m.d.heartbeat_interval / 1e3
		self.log.debug('Heartbeat interval: {:,.2f}', interval)
		self.ws_tasks.add(self.op_heartbeat_task(interval))
		await self.op_hello_auth()
		return True

	async def op_hello_auth(self):
		self.state('hello.auth.token')
		token = await self.req_auth_token()
		if not self.st.get('session_id'):
			self.state('hello.auth.identify')
			self.ws_add_handler(self.c.dispatch, t='ready', func=self.op_ready)
			self.ws_send(self.c.identify, dict(
				properties={'$os': 'linux', '$browser': 'rdircd', '$device': 'rdircd'},
				token=token, compress=False, large_threshold=250 ))
		else:
			self.state('hello.auth.resume')
			self.ws_add_handler(self.c.dispatch, t='resumed', func=self.op_ready)
			self.ws_send(self.c.resume, dict(
				token=token, session_id=self.st.session_id, seq=self.st.get('seq') ))

	async def op_heartbeat_task(self, interval):
		self.st.hb_ts_ack = hb_ts = self.loop.time() + interval
		self.ws_add_handler(self.c.heartbeat_ack, self.op_heartbeat_ack)
		while not self.ws_closed.is_set():
			self.ws_send(self.c.heartbeat, self.st.get('seq'))
			ts = self.loop.time()
			if self.st.hb_ts_ack < ts - interval*2:
				self.state('heartbeat.fail')
				self.log.error('Missing heartbeat ack, reconnecting')
				return await self.ws_close()
			while hb_ts <= ts: hb_ts += interval
			delay = hb_ts - ts
			await asyncio.sleep(delay)

	def op_heartbeat_ack(self, m):
		self.st.hb_ts_ack = self.loop.time()

	async def op_invalid_session_retry(self, m):
		self.log.info(
			'Session/auth rejected during handshake'
			' - updating auth token and retrying after delay' )
		# "expected to wait a random amount of time -
		#  - between 1 and 5 seconds - then send a fresh Opcode 2 Identify"
		self.state('session.error.delay')
		await asyncio.sleep(1 + random.random() * 4)
		self.auth_token = None
		self.ws_add_handler( self.c.invalid_session,
			self.op_invalid_session_fail, replace=True )
		self.state('session.error')
		await self.op_hello_auth()

	async def op_invalid_session_fail(self, m):
		self.log.info('Session/auth rejected unexpectedly - closing connection')
		self.state('session.fail')
		await self.ws_close()

	def op_ready(self, m):
		md = m.get('d')
		if md:
			self.st.update(
				session_id=md.session_id,
				user_id=md.user.id,
				user_name=md.user.username,
				user_n=md.user.discriminator )
			# XXX: check "guilds" state for more useful info
			self.op_guild_update(guild=md.get('guilds'))
		self.state('ready')
		self.ws_add_handler(self.c.dispatch, func=self.op_guild_event)
		self.ws_add_handler( self.c.invalid_session,
			self.op_invalid_session_fail, replace=True )
		return True

	def op_guild_event(self, m):
		mt = (m.get('t') or '').lower()
		try: o, act = mt.rsplit('_', 1)
		except ValueError: return
		try: gid = m.d.guild_id
		except: gid = None
		if o == 'guild':
			if act in ['create', 'update']: self.op_guild_update(gid, guild=m.d)
			elif act == 'delete': self.op_guild_delete(gid)
		elif o == 'channel':
			if act in ['create', 'update']: self.op_guild_update(gid, chan=m.d)
			elif act == 'delete': self.op_guild_delete(gid, chan=m.d.id)
		elif o == 'guild_member':
			if act in ['add', 'update']: self.op_guild_update(gid, user=m.d.user)
			elif act == 'delete': self.op_guild_delete(gid, user=m.d.user.id)
		# XXX: actual messages
		# elif o == 'message':
		# elif o == 'message_reaction':
		# elif o == 'relationship':
		# elif o == 'channel_pins':
		# elif o == 'presence':

	def op_guild_update(self, gid=None, guild=..., user=..., chan=...):
		gs = self.st.setdefault('guilds', dict())
		if guild is not ...:
			gs_new = dict()
			for g in force_list(guild):
				gg = gs_new.setdefault( g.id,
					gs.get(g.id, adict(id=g.id, chans=dict(), users=dict())) )
				gg.update(name=g.name)
				self.op_guild_update(g.id, user=g.get('members'), chan=g.get('channels'))
				# XXX: check/process presences, voice states, any other info
			dict_sync(gs, gs_new)
		gg = gs.get(gid) if not isinstance(gid, adict) else gid
		if not gg: return
		if users is not ...:
			dict_sync( gg.users,
				((u.id, adict(id=u.id, name=u.username)) for u in force_list(user)) )
		if chan is not ...:
			cs = dict()
			for c in force_list(chan):
				cc = cs.setdefault(c.id, gg.chans.get(c.id, adict()))
				cc.update(
					id=c.id, name=c.name, t=ct.c_chan_type(c.type),
					topic=c.get('topic'), msg_last_id=c.get('last_message_id') )
				if cc.t in [ct.c_chan_type.private, ct.c_chan_type.private_group]:
					us = cc.setdefault('users', dict()).update(
						(u.id, adict(name=u.username))
						for u in (c.get('recipients') or list()) )
				elif cc.t == ct.c_chan_type.text: pass
				elif cc.t == ct.c_chan_type.voice: pass # for /list only
				else: self.log.warning('Unknown chan type: {}', cc)
			dict_sync(gg.chans, cs)

	def op_guild_delete(self, gid=None, user=..., chan=...):
		gs = self.st.setdefault('guilds', dict())
		gg = gs.get(gid)
		if not gg: return
		if user is not ...: gg.users.pop(user, None)
		elif chan is not ...: gg.chans.pop(chan, None)
		else: gs.pop(gid, None)

	# Not handled:
	#
	# - After READY: op=0 t=SESSIONS_REPLACE s=2
	#   d=[{ status=online, session_id=..., game=null,
	#     client_info={version=0, os=other, client=web}, activities=[] }]



class RDIRCD:

	def __init__(self, loop, conf):
		self.loop, self.conf = loop, conf
		self.log = get_logger('rdircd.bridge')

	async def __aenter__(self):
		self.server_ver = '1.0.0'
		self.server_ts = dt.datetime.utcnow()
		self.server_host = os.uname().nodename
		self.irc_conns, self.irc_conns_max = dict(), 0
		self.irc_auth_tbf = token_bucket(self.conf.irc_auth_tbf)
		self.nick_sys, self.chans_sys = 'core', dict(
			control='rdircd control channel, type "help" for more info',
			debug='rdircd debug logging channel, read-only' )
		self.tasks = StacklessContext()
		return self

	async def __aexit__(self, *err):
		if self.tasks: await self.tasks.close()

	async def run(self):
		ircd = await self.loop.create_server(
			IRCProtocol.factory_for_bridge(self),
			self.conf.irc_host, self.conf.irc_port,
			family=self.conf.irc_host_af, start_serving=False )
		self.log.debug('Initializing discord...')
		try:
			async with Discord(self) as discord:
				self.log.debug('Starting ircd...')
				ircd_task = self.tasks.add(ircd.serve_forever())
				if self.conf.discord_auto_connect:
					self.log.debug('Auto-connecting discord...')
					self.loop.call_soon(discord.connect)
				await ircd_task
		except DiscordAbort as err:
			self.log.error('Discord init failure - {}', err_fmt(err))
		self.log.debug('Finished')

	async def run_async(self):
		async with self: await self.run()


	def irc_conn_new(self, irc):
		self.irc_conns[id(irc)] = irc
		self.irc_conns_max = max(self.irc_conns_max, len(self.irc_conns))
	def irc_conn_lost(self, irc): self.irc_conns.pop(id(irc), None)
	def irc_conn_stats(self):
		stats = adict(
			servers=1, chans=0, # XXX: number of servers/chans from discord
			total=0, total_max=self.irc_conns_max, unknown=0, auth=0, op=0 )
		for conn in self.irc_conns.values():
			stats.total += 1
			if conn.st.auth: stats.auth += 1
			else: stats.unknown += 1
		return stats


	def cmd_delay(self, delay, func):
		if delay and not isinstance(delay, (int, float)):
			if delay == 'irc_auth': delay = next(self.irc_auth_tbf)
			else: raise ValueError(delay)
		if delay: self.tasks.add(asyncio.sleep(delay), func)
		else: func()

	def cmd_conn(self, name=None):
		for conn in self.irc_conns.values():
			if not name or name == conn.st.nick: return conn
	@iter_gather(list)
	def cmd_chan_conns(self, name):
		for conn in self.irc_conns.values():
			if name in conn.st.chans: yield conn
	# XXX: def cmd_chan_names_discord(self, name):
	@iter_gather(list)
	def cmd_chan_names(self, name):
		for conn in self.cmd_chan_conns(name): yield conn.st.nick
		# XXX: cmd_chan_names_discord()

	@iter_gather(adict)
	def cmd_chan_map(self):
		for name, topic in self.chans_sys.items():
			yield (name, adict( name=name, topic=topic,
				names=self.cmd_chan_names(name),
				ts_created=self.server_ts.timestamp() ))
		# XXX: list discord channels/users here as well

	def cmd_control_status(self, conn, chan):
		for line in [
				'Status:',
				'  XXX: show whether stuff is connected and working atm' ]:
			conn.cmd_msg_synth(self.nick_sys, chan, line)

	def cmd_control(self, conn, text, chan):
		line = text.strip().split()
		if not line: return
		cmd, send = line[0],\
			ft.partial(conn.cmd_msg_synth, self.nick_sys, chan)
		if cmd == 'help':
			self.cmd_control_status(conn, chan)
			for line in [
					'Commands:',
					'  status - (alias: st) show whether discord is connected and working',
					'  connect - (alias: on) connect/login to discord api',
					'  disconnect - (alias: off) disconnect from discord' ]:
				send(line)
		elif cmd in ['status', 'st']: self.cmd_control_status(conn, chan)
		elif cmd in ['connect', 'on']:
			send('discord: connecting...')
			self.discord.connect()
		elif cmd in ['disconnect', 'off']:
			send('discord: disconnecting...')
			self.discord.disconnect()

	def cmd_log(self, line):
		conn = self.cmd_conn()
		if not conn: return
		conn.cmd_msg_synth(self.nick_sys, '#debug', line)



class RDIRCDConfig:

	version = '1.0'

	irc_host = '127.0.0.1'
	irc_port = 6667
	irc_password = ''
	irc_host_af = 0
	irc_auth_tbf = '30:8'

	discord_auto_connect = False
	discord_api_url = 'https://discordapp.com/api/v{api_ver}/'
	discord_ws_timeout = 20.0
	discord_ws_heartbeat = 15.0
	discord_ws_debug = True
	discord_user_agent = ( f'rdircd/{version}'
		f' (reliable-discord-irc-client) aiohttp/{aiohttp.__version__}' )
	discord_http_delay_padding = 10.0 # added to retry_after
	discord_gateway = ''

	auth_main_email = ''
	auth_main_password = ''
	auth_main_token = ''

	auth_ghost_email = ''
	auth_ghost_password = ''
	auth_ghost_token = ''

	debug_verbose = False
	debug_str_cut = 0

	# XXX: options for well-timestamped protocol logs

	_conf_path = '~/.rdircd.ini'
	_conf_sections = 'irc', 'discord', 'auth_main', 'auth_ghost', 'debug'

	def __repr__(self): return repr(vars(self))
	def get(self, *k): return getattr(self, '_'.join(k))
	def set(self, k, v): setattr(self, k, v)

	def pprint(self, title=None, empty_vals=False):
		cat, chk = None, re.compile(
			'^({})_(.*)$'.format('|'.join(map(re.escape, self._conf_sections))) )
		if title: print(f';; {title}')
		for k in sorted(dir(self)):
			m = chk.search(k)
			if not m: continue
			v = self.get(k)
			if not empty_vals and not v: continue
			cat_chk = m.group(1).replace('_', '-')
			if cat_chk != cat:
				cat = cat_chk
				print(f'\n[{cat}]')
			if isinstance(v, bool): v = ['no', 'yes'][v]
			k = m.group(2).replace('_', '-')
			print(f'{k} = {v}')

	def update_from_file(self, config, section='default', prefix=None):
		section = section.replace('_', '-')
		for k in dir(self):
			if prefix:
				if not k.startswith(prefix): continue
				conf_k, k = k, k[len(prefix):]
			elif k.startswith('_'): continue
			else: conf_k = k
			v = getattr(self, conf_k)
			if isinstance(v, str): get_val = lambda *a: str(config.get(*a, raw=True))
			elif isinstance(v, bool): get_val = config.getboolean
			elif isinstance(v, int): get_val = lambda *a: int(re.sub(r'[ _]', '', config.get(*a)))
			elif isinstance(v, float): get_val = lambda *a: float(config.get(*a))
			else: continue # values with other types cannot be specified in config
			for k_conf in {k, k.replace('_', '-')}:
				try: self.set(conf_k, get_val(section, k_conf))
				except configparser.NoSectionError: pass
				except configparser.NoOptionError: pass

	def update_file_section(self, section, keys=None, path=None):
		section = section.replace('_', '-')
		if not path: path = self._conf_path
		if isinstance(path, str): path = pl.Path(path)
		sec_re, sec_k = re.compile(r'(?i)^\[\s*(\S+)\s*\]$'), str_norm(section)
		sec_prefix = section.lower().replace('-', '_') + '_'
		if not keys: keys = list(k for k in vars(self).keys() if k.startswith(sec_prefix))
		if isinstance(keys, str): keys = keys.split()
		for n, k in enumerate(keys):
			if not k.startswith(sec_prefix): k = sec_prefix + k
			k, v = k[len(sec_prefix):].replace('_', '-'), self.get(k)
			if isinstance(v, bool): v = ['no', 'yes'][v]
			keys[n] = k, v, re.compile(r'(?i)^' + k.replace('-', '[-_]') + r'\s*=')
		keys = dict((k, (v, rx)) for k, v, rx in keys)
		with path.open() as src, safe_replacement(path) as dst:
			lines, sec, sec_parse = list(), list(), False
			for n, line in enumerate(src):
				m, line = sec_re.search(line.strip()), line.rstrip()
				if m:
					k = str_norm(m.group(1))
					if k == sec_k:
						sec_parse = True
						if sec: line = '' # drop duplicate headers
					if k != sec_k: sec_parse = False
				if sec_parse: sec.append(line)
				else: lines.append(line)
			while sec and not sec[-1]: sec.pop()
			if not sec: sec.append(f'[{section}]')
			if lines and lines[-1]: lines.append('')
			for line in lines: dst.write(f'{line}\n')
			for n, line in enumerate(sec):
				for k, (v, rx) in keys.items():
					if not rx.search(line): continue
					if v is None: line = None
					else: line, keys[k] = f'{k} = {v}', (None, rx)
				if line is not None: dst.write(f'{line}\n')
			for k, (v, rx) in keys.items():
				if v is None: continue
				dst.write(f'{k} = {v}\n')



def main(args=None, conf=None):
	if not conf: conf = RDIRCDConfig()

	import argparse, textwrap
	dedent = lambda text: (textwrap.dedent(text).strip('\n') + '\n').replace('\t', '  ')
	text_fill = lambda s,w=100,ind='\t',ind_next=None,**k: textwrap.fill(
		s, w, initial_indent=ind, subsequent_indent=ind if ind_next is None else ind_next, **k )
	class SmartHelpFormatter(argparse.HelpFormatter):
		def __init__(self, *args, **kws):
			return super().__init__(*args, **kws, width=100)
		def _fill_text(self, text, width, indent):
			if '\n' not in text: return super()._fill_text(text, width, indent)
			return ''.join( indent + line
				for line in text.replace('\t', '  ').splitlines(keepends=True) )
		def _split_lines(self, text, width):
			return super()._split_lines(text, width)\
				if '\n' not in text else dedent(text).splitlines()

	parser = argparse.ArgumentParser(
		formatter_class=SmartHelpFormatter,
		description='Reliable personal discord-client to irc-server translation daemon.')

	group = parser.add_argument_group('Configuration file(s)')
	group.add_argument('-c', '--conf',
		metavar='file', action='append',
		help=f'''
			Path to configuration file to use.
			It will get updated with OAuth2 credentials
				(only adding or changing [auth] section), so has to be writable.
			Default: {conf._conf_path}''')
	group.add_argument('--conf-dump', action='store_true',
		help='Print all configuration settings, which will be used with'
			' currently detected (and/or specified) configuration file(s), and exit.')
	group.add_argument('--conf-dump-defaults', action='store_true',
		help='Print all default settings, which would be used'
			' if no configuration file(s) were overriding these, and exit.')

	group = parser.add_argument_group('Interfaces')
	group.add_argument('-i', '--irc-bind', metavar='host(:port)',
		help=f'''
			Address/host (to be resolved via gai) and port to bind IRC server to.
			When specifying port after raw IPv6 address,
				enclose the latter in [], for example - [::]:6667.
			Default: {conf.irc_host}:{conf.irc_port} or whatever is in --conf file.''')

	group = parser.add_argument_group('Misc / debug opts')
	group.add_argument('-d', '--debug', action='store_true', help='Verbose operation mode.')
	group.add_argument('-t', '--str-cut', type=int, metavar='n',
		help='Truncate long strings in protocol dumps to specified length.'
			' Set to <=0 to disable truncation (default).')

	opts = parser.parse_args(sys.argv[1:] if args is None else args)

	if opts.conf_dump_defaults:
		conf.pprint('Default configuration options', empty_vals=True)
		return

	conf_file = configparser.ConfigParser(allow_no_value=True)
	conf_user_paths = list(map(
		os.path.expanduser, opts.conf or [conf._conf_path] ))
	for n, p in enumerate(conf_user_paths):
		mode = os.R_OK
		if n == len(conf_user_paths) - 1: mode |= os.W_OK
		if not os.access(p, mode):
			parser.error(f'Specified config file missing or inaccessible: {p}')
	conf_file.read(conf_user_paths)
	for k in conf._conf_sections:
		conf.update_from_file(conf_file, section=k, prefix=f'{k}_')
	conf._conf_path = conf_user_paths[-1]

	if opts.conf_dump:
		conf.pprint('Current configuration options')
		return

	if opts.debug: conf.debug_verbose = True
	if opts.str_cut: conf.debug_str_cut = opts.str_cut

	log_fmt = '%(name)s %(levelname)5s :: %(message)s'
	if conf.debug_verbose: log_fmt = '%(asctime)s :: ' + log_fmt
	log_fmt = logging.Formatter(log_fmt)
	log_handler = logging.StreamHandler(sys.stderr)
	log_handler.setLevel( logging.DEBUG
		if conf.debug_verbose else logging.WARNING )
	log_handler.setFormatter(log_fmt)
	logging.root.addHandler(log_handler)
	logging.root.setLevel(0)
	log = get_logger('main')

	host, port, family = opts.irc_bind or conf.irc_host, conf.irc_port, conf.irc_host_af
	if host.count(':') > 1: host, port = str_part(host, ']:>', port)
	else: host, port = str_part(host, ':>', port)
	if '[' in host: family = socket.AF_INET6
	host, port = host.strip('[]'), int(port)
	try:
		addrinfo = socket.getaddrinfo( host, str(port),
			family=family, type=socket.SOCK_STREAM, proto=socket.IPPROTO_TCP )
		if not addrinfo: raise socket.gaierror('No addrinfo for host: {}'.format(host))
	except (socket.gaierror, socket.error) as err:
		parser.error( 'Failed to resolve irc socket parameters (address, family)'
			' via getaddrinfo: {!r} - [{}] {}'.format((host, port), err.__class__.__name__, err) )
	sock_af, sock_t, sock_p, _, sock_addr = addrinfo[0]
	log.debug(
		'Resolved irc host:port {!r}:{!r} to endpoint: {} (family: {}, type: {}, proto: {})',
		host, port, sock_addr, *(sockopt_resolve(pre, n)
			for pre, n in [('af_', sock_af), ('sock_', sock_t), ('ipproto_', sock_p)]) )
	assert ( sock_t == socket.SOCK_STREAM
		and sock_p == socket.IPPROTO_TCP ), [sock_t, sock_p]
	conf.irc_host_af, (conf.irc_host, conf.irc_port) = sock_af, sock_addr[:2]

	def handle_exception(err_t, err, err_tb):
		log.error('Unhandled error: {}', err_fmt(err), exc_info=(err_t, err, err_tb))
	sys.excepthook = handle_exception

	log.debug('Starting eventloop...')
	with contextlib.closing(asyncio.get_event_loop()) as loop:
		# if conf.debug_verbose: loop.set_debug(True)
		rdircd = RDIRCD(loop, conf)

		log_handler = LogFuncHandler(rdircd.cmd_log)
		log_handler.setLevel(logging.DEBUG if conf.debug_verbose else logging.INFO)
		log_handler.setFormatter(logging.Formatter('%(name)s %(levelname)5s :: %(message)s'))
		logging.root.addHandler(log_handler)

		rdircd_task = loop.create_task(rdircd.run_async())
		for sig in 'INT TERM'.split():
			loop.add_signal_handler(getattr(signal, f'SIG{sig}'), rdircd_task.cancel)
		with contextlib.suppress(asyncio.CancelledError):
			return loop.run_until_complete(rdircd_task)
	log.debug('Finished')

if __name__ == '__main__': sys.exit(main())
